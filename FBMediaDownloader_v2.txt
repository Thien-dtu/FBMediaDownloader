# ==================================================
# Path: D:\Tools\FBMediaDownloader
# Detected tech: c, cpp, javascript, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
FBMediaDownloader/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ downloads/
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.users.test.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ profile.save.test.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.test.js
‚îÇ   ‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ menu/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ album.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wall.js
‚îÇ   ‚îú‚îÄ‚îÄ profile/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fetch.js
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ save.js
‚îÇ   ‚îú‚îÄ‚îÄ batch_utils.js
‚îÇ   ‚îú‚îÄ‚îÄ bookmarks.js
‚îÇ   ‚îú‚îÄ‚îÄ cancellation.js
‚îÇ   ‚îú‚îÄ‚îÄ constants.js
‚îÇ   ‚îú‚îÄ‚îÄ database.js
‚îÇ   ‚îú‚îÄ‚îÄ download_album.js
‚îÇ   ‚îú‚îÄ‚îÄ download_helpers.js
‚îÇ   ‚îú‚îÄ‚îÄ download_timeline_album.js
‚îÇ   ‚îú‚îÄ‚îÄ download_user_photos.js
‚îÇ   ‚îú‚îÄ‚îÄ download_user_videos.js
‚îÇ   ‚îú‚îÄ‚îÄ download_wall_media.js
‚îÇ   ‚îú‚îÄ‚îÄ downloader.db
‚îÇ   ‚îú‚îÄ‚îÄ lang.js
‚îÇ   ‚îú‚îÄ‚îÄ logger.js
‚îÇ   ‚îú‚îÄ‚îÄ menu.js
‚îÇ   ‚îú‚îÄ‚îÄ proxy_manager.js
‚îÇ   ‚îú‚îÄ‚îÄ rate_limit_manager.js
‚îÇ   ‚îú‚îÄ‚îÄ shared_readline.js
‚îÇ   ‚îú‚îÄ‚îÄ sql_playground.js
‚îÇ   ‚îú‚îÄ‚îÄ sql_web.js
‚îÇ   ‚îú‚îÄ‚îÄ token_manager.js
‚îÇ   ‚îú‚îÄ‚îÄ token_validator.js
‚îÇ   ‚îú‚îÄ‚îÄ user_info.js
‚îÇ   ‚îú‚îÄ‚îÄ user_profile.js
‚îÇ   ‚îî‚îÄ‚îÄ utils.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ FBMediaDownloader.txt
‚îú‚îÄ‚îÄ auto.bat
‚îú‚îÄ‚îÄ config.example.js
‚îú‚îÄ‚îÄ config.js
‚îú‚îÄ‚îÄ downloader.db
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ proxies.example.txt
‚îú‚îÄ‚îÄ proxies.txt
‚îú‚îÄ‚îÄ schema.sql
‚îú‚îÄ‚îÄ vitest.config.js
‚îî‚îÄ‚îÄ yarn.lock
```

## FILE CONTENTS

### config.example.js
```js
// Configuration management using dotenv
// Copy .env.example to .env and fill in your values
// DO NOT commit .env to version control!

import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// ========== ACCESS TOKEN ==========
// Get your Facebook access token from: https://developers.facebook.com/tools/explorer/
export const ACCESS_TOKEN = process.env.FB_ACCESS_TOKEN || "";

// ========== TIMING CONFIGURATION ==========
export const WAIT_BEFORE_NEXT_FETCH = parseInt(process.env.WAIT_BEFORE_NEXT_FETCH) || 500;
export const WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO = parseInt(process.env.WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO) || 500;

// ========== MISC ==========
export const ID_LINK_SEPERATOR = ";";
export const FOLDER_TO_SAVE_LINKS = "./links";  // Folder to save txt files with links

// ========== DATABASE CONFIGURATION ==========
export const DATABASE_ENABLED = process.env.DATABASE_ENABLED !== 'false';
export const DATABASE_PATH = process.env.DATABASE_PATH || './downloader.db';

// ========== PLATFORM IDS ==========
export const PLATFORM_FACEBOOK = 1;
export const PLATFORM_INSTAGRAM = 2;

// ========== UNIFIED FOLDER STRUCTURE ==========
// All downloads now go to: downloads/{userId}/photos/ or downloads/{userId}/videos/
export const DOWNLOADS_FOLDER = process.env.DOWNLOADS_FOLDER || './downloads';

/**
 * Get save folder path for a user's media
 * @param {string} userId - User ID
 * @param {string} mediaType - 'photos' or 'videos'
 * @returns {string} Folder path
 */
export function getSaveFolderPath(userId, mediaType) {
    return `${DOWNLOADS_FOLDER}/${userId}/${mediaType}`;
}

// ========== FILE FORMATS ==========
export const PHOTO_FILE_FORMAT = process.env.PHOTO_FILE_FORMAT || "png";
export const VIDEO_FILE_FORMAT = process.env.VIDEO_FILE_FORMAT || "mp4";

```

### config.js
```js
import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// ========== ACCESS TOKEN ==========
export const ACCESS_TOKEN = process.env.FB_ACCESS_TOKEN || "";

// ========== TIMING CONFIGURATION ==========
export const WAIT_BEFORE_NEXT_FETCH = parseInt(process.env.WAIT_BEFORE_NEXT_FETCH) || 3000; // th·ªùi gian ch·ªù (ms) tr∆∞·ªõc m·ªói l·∫ßn fetch ti·∫øp theo
export const WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO = parseInt(process.env.WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO) || 3000; // th·ªùi gian ch·ªù (ms) tr∆∞·ªõc khi t·∫£i ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i l·ªõn. N·∫øu ch·ªù √≠t th√¨ r·∫•t d·ªÖ b·ªã facebook ban

// ========== MISC ==========
export const ID_LINK_SEPERATOR = ";";
export const FOLDER_TO_SAVE_LINKS = "./links";  // Folder to save txt files with links

// ========== DATABASE CONFIGURATION ==========
export const DATABASE_ENABLED = process.env.DATABASE_ENABLED !== 'false';  // Re-enabled
export const DATABASE_PATH = process.env.DATABASE_PATH || './downloader.db';

// ========== PLATFORM IDS ==========
export const PLATFORM_FACEBOOK = 1;
export const PLATFORM_INSTAGRAM = 2;

// ========== UNIFIED FOLDER STRUCTURE ==========
// All downloads now go to: downloads/{userId}/photos/ or downloads/{userId}/videos/
export const DOWNLOADS_FOLDER = process.env.DOWNLOADS_FOLDER || './downloads';

/**
 * Get save folder path for a user's media
 * @param {string} userId - User ID
 * @param {string} mediaType - 'photos' or 'videos'
 * @returns {string} Folder path
 */
export function getSaveFolderPath(userId, mediaType) {
    return `${DOWNLOADS_FOLDER}/${userId}/${mediaType}`;
}

// ========== FILE FORMATS ==========
export const PHOTO_FILE_FORMAT = process.env.PHOTO_FILE_FORMAT || "png"; // OR jpg
export const VIDEO_FILE_FORMAT = process.env.VIDEO_FILE_FORMAT || "mp4"; // OR wav ?

```

### index.js
```js
import { menu } from "./scripts/menu.js";
import { initDatabase } from "./scripts/database.js";
import { DATABASE_ENABLED } from "./config.js";
import { ensureValidToken } from "./scripts/token_validator.js";

// Main startup function
(async () => {
    // Initialize database if enabled
    if (DATABASE_ENABLED) {
        try {
            initDatabase();
            console.log("‚úÖ Database initialized - Duplicate detection enabled");
        } catch (e) {
            console.log("‚ö†Ô∏è  Database initialization failed, continuing without tracking");
            console.log("   Error:", e.message);
        }
    }

    // Validate token and display status
    const tokenValid = await ensureValidToken();
    if (!tokenValid) {
        console.log("Exiting due to invalid token.");
        process.exit(1);
    }

    // Launch main menu
    menu();
})();

// Danh s√°ch timeline album ƒë·∫πp
// ColourfulSpace: https://www.facebook.com/media/set/?vanity=ColourfulSpace&set=a.945632905514659
// J2Team-Girl: https://www.facebook.com/media/set/?set=oa.245004546697321&type=3
// J2Team-Girl: https://www.facebook.com/media/set/?set=oa.628769808043090&type=3
// AnhGirlXinh: https://www.facebook.com/media/set/?vanity=anhgirlxinh.net&set=a.568433099885020
// NgamGaiDep: https://www.facebook.com/media/set/?vanity=ngamgaidep.plus&set=a.1885102325148609

```

### vitest.config.js
```js
import { defineConfig } from 'vitest/config';

export default defineConfig({
    test: {
        globals: true,
        environment: 'node',
        include: ['scripts/**/*.test.js'],
        // Save test results to files
        reporters: ['default', 'json', 'html'],
        outputFile: {
            json: './test-results/results.json',
            html: './test-results/index.html',
        },
        coverage: {
            provider: 'v8',
            reporter: ['text', 'html'],
            reportsDirectory: './test-results/coverage',
            include: ['scripts/**/*.js'],
            exclude: [
                'scripts/**/*.test.js',
                'scripts/bookmarks.js',
                'scripts/sql_playground.js',
                'scripts/sql_web.js',
            ],
        },
    },
});

```

### scripts\batch_utils.js
```js
import { sleep } from "./utils.js";
import { isCancelled } from "./cancellation.js";
import { S } from "./constants.js";
import { log } from "./logger.js";

/**
 * Print standardized batch download summary
 * @param {Array} results - Array of download results
 * @param {number} startTime - Start timestamp
 * @param {object} options - Configuration options
 * @param {string} options.mediaType - Type of media: 'photos', 'videos', or 'media'
 * @param {boolean} options.showPhotoVideoSplit - Show separate photo/video counts (for wall media)
 * @param {boolean} options.wasCancelled - Whether the batch was cancelled
 */
export const printBatchSummary = (results, startTime, options = {}) => {
    const { mediaType = 'media', showPhotoVideoSplit = false, wasCancelled = false } = options;
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    const duration = ((Date.now() - startTime) / 1000).toFixed(1);

    console.log('\n' + '='.repeat(50));
    console.log('BATCH SUMMARY'.padStart(32));
    console.log('='.repeat(50));

    if (wasCancelled) {
        console.log(S.FgYellow + '‚ö†Ô∏è  Batch was cancelled by user' + S.Reset);
    }

    console.log(`Total Users: ${results.length}`);
    console.log(`Successful: ${successful.length}`);
    console.log(`Failed: ${failed.length}`);

    if (successful.length > 0) {
        if (showPhotoVideoSplit) {
            // Wall media has separate photo/video counts
            const totalPhotos = successful.reduce((sum, r) => sum + (r.savedPhotos || 0), 0);
            const totalVideos = successful.reduce((sum, r) => sum + (r.savedVideos || 0), 0);
            const totalSkipped = successful.reduce((sum, r) => sum + (r.skipped || 0), 0);
            console.log(`Total Media Downloaded: ${totalPhotos} photos, ${totalVideos} videos`);
            console.log(`Total Skipped (duplicates): ${totalSkipped}`);
        } else {
            // Simple saved/skipped counts for photos or videos only
            const totalSaved = successful.reduce((sum, r) => sum + (r.saved || 0), 0);
            const totalSkipped = successful.reduce((sum, r) => sum + (r.skipped || 0), 0);
            const label = mediaType.charAt(0).toUpperCase() + mediaType.slice(1);
            console.log(`Total ${label} Downloaded: ${totalSaved}`);
            console.log(`Total Skipped (duplicates): ${totalSkipped}`);
        }
    }

    if (failed.length > 0) {
        console.log('\nFailed Users:');
        failed.forEach(r => {
            console.log(`  - ${r.userId}: ${r.error}`);
        });
    }

    console.log(`Time Elapsed: ${duration}s`);
    console.log('='.repeat(50) + '\n');
};

/**
 * Run batch download with consistent error handling and progress reporting
 * @param {string[]} userIds - Array of user IDs to process
 * @param {Function} downloadFn - Single-user download function (receives { targetId, ...options })
 * @param {object} options - Options to pass to each download function call
 * @param {object} config - Batch configuration
 * @param {string} config.mediaType - Type of media: 'photos', 'videos', or 'wall media'
 * @param {boolean} config.showPhotoVideoSplit - Show separate photo/video counts in summary
 * @param {number} config.delayBetweenUsers - Delay in ms between processing users (default: 1000)
 * @returns {Array} Array of results with userId, success, and download stats
 */
export const runBatchDownload = async (userIds, downloadFn, options = {}, config = {}) => {
    const {
        mediaType = 'media',
        showPhotoVideoSplit = false,
        delayBetweenUsers = 1000
    } = config;

    const results = [];
    const totalUsers = userIds.length;
    const startTime = Date.now();
    let wasCancelled = false;

    console.log(`\nüì¶ Processing ${totalUsers} user(s)...\n`);

    for (let i = 0; i < totalUsers; i++) {
        // Check for cancellation before each user
        if (isCancelled()) {
            log(S.FgYellow + `‚è∏Ô∏è  Batch cancelled after ${i} of ${totalUsers} users` + S.Reset);
            wasCancelled = true;
            break;
        }

        const userId = userIds[i];
        console.log(`[${i + 1}/${totalUsers}] Downloading ${mediaType} from user ${userId}...`);

        try {
            const result = await downloadFn({
                targetId: userId,
                ...options
            });

            results.push({
                userId,
                success: true,
                ...result
            });

            // Log individual result
            if (showPhotoVideoSplit && result.savedPhotos !== undefined) {
                console.log(`‚úÖ User ${userId}: ${result.savedPhotos} photos, ${result.savedVideos} videos saved | ${result.skippedPhotos || 0}+${result.skippedVideos || 0} skipped`);
            } else {
                console.log(`‚úÖ User ${userId}: ${result.saved} saved, ${result.skipped} skipped`);
            }

        } catch (error) {
            results.push({
                userId,
                success: false,
                error: error.message
            });

            console.log(`‚ùå User ${userId}: ${error.message}`);
        }

        // Small delay between users to avoid rate limiting
        if (i < totalUsers - 1 && delayBetweenUsers > 0 && !isCancelled()) {
            await sleep(delayBetweenUsers);
        }
    }

    // Print summary
    printBatchSummary(results, startTime, { mediaType, showPhotoVideoSplit, wasCancelled });

    return results;
};

```

### scripts\bookmarks.js
```js
// (M·ªöI) C·∫¨P NH·∫¨T C√ÅCH L·∫§Y TOKEN M·ªöI - D√ôNG WEB H·ªñ TR·ª¢
// https://ffb.vn/get-token
// L∆ØU √ù: ƒê√ÇY L√Ä WEB B√äN TH·ª® 3, S·ª¨ D·ª§NG COOKIES ƒê·ªÇ L·∫§Y TOKEN, M√åNH KH√îNG ƒê·∫¢M B·∫¢O COOKIES C·ª¶A B·∫†N ƒê∆Ø·ª¢C AN TO√ÄN :)

// (C≈®) C·∫¨P NH·∫¨T C√ÅCH L·∫§Y TOKEN FULL QUY·ªÄN (01/03/2022):
// (20/8/2022) TOKEN N√ÄY KH√îNG C√íN FULL QUY·ªÄN
javascript: (function () {
  if (window.location.host !== "business.facebook.com") {
    alert(
      "Bookmark n√†y ch·ªâ ho·∫°t ƒë·ªông tr√™n trang https://business.facebook.com/content_management/\nB·∫°n h√£y v√†o trang web tr√™n v√† ·∫•n l·∫°i bookmark ƒë·ªÉ l·∫•y token an to√†n nh√©."
    );
    window.open("https://business.facebook.com/content_management/");
    return;
  }

  try {
    const accessToken =
      "EAAG" + /(?<=EAAG)(.*?)(?=\")/.exec(document.body.textContent)[0];
    window.prompt("Access Token c·ªßa b·∫°n:", accessToken);
  } catch (e) {
    alert("L·ªñI: " + e.message);
  }
})();

// (C≈®) QUAN TR·ªåNG: L·∫§Y ACCESS TOKEN FULL QUY·ªÄN, C√ÅC B·∫†N L√ÄM THEO H∆Ø·ªöNG D·∫™N TRONG LINK SAU:
// https://alotoi.com/get-token-full-quyen/#Cach_1_Get_token_qua_ung_dung_Instagram

// 2 C√ÅI L·∫§Y TOKEN PH√çA D∆Ø·ªöI HI·ªÜN ƒêANG L·ªñI N√äN M·ªåI NG∆Ø·ªúI ƒê·ª™NG X√ÄI NH√â.

// (C≈®) L·∫•y access token (kh√¥ng th·ªùi h·∫°n, full quy·ªÅn, user token) - Ch·ªâ g·ªçi ƒë∆∞·ª£c h√†m n√†y trong trang m.facebook.com
// - HI·ªÜN ƒêANG L·ªñI, FB KH√îNG C√íN C√îNG KHAI ACCESSTOKEN N·ªÆA, N√äN H√ÄM N√ÄY S·∫º KO L·∫§Y ƒêC ACCESSTOKEN
javascript: (function () {
  if (window.location.host !== "m.facebook.com") {
    alert(
      "Bookmark n√†y ch·ªâ ho·∫°t ƒë·ªông tr√™n trang m.facebook.com\nB·∫°n h√£y v√†o trang m.facebook.com v√† ·∫•n l·∫°i bookmark ƒë·ªÉ l·∫•y token an to√†n nh√©."
    );
    window.open("https://m.facebook.com");
    return;
  }
  console.log("ƒêang l·∫•y token ...");
  fetch("https://m.facebook.com/composer/ocelot/async_loader/?publisher=feed")
    .then((response) => response.text())
    .then((text) => {
      if ("<" == text[0]) {
        alert("Ch∆∞a ƒëƒÉng nh·∫≠p. B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p fb th√¨ m·ªõi l·∫•y ƒë∆∞·ª£c token.");
      } else {
        const data = {
          token: /(?<=accessToken\\":\\")(.*?)(?=\\")/.exec(text)[0],
          fb_dtsg: /(?<=fb_dtsg\\" value=\\")(.*?)(?=\\")/.exec(text)[0],
          id: /(?<=USER_ID\\":\\").*?(?=\\",\\")/gm.exec(text)[0],
        };
        console.log(data);
        window.prompt("Access Token c·ªßa b·∫°n:", data.token);
      }
    });
})();

// (C≈®) L·∫•y access token (c√≥ th·ªùi h·∫°n. app token) D√πng cho www.facebook.com
// - HI·ªÜN ƒêANG L·ªñI: BOOKMARK n√†y kh√¥ng to√†n quy·ªÅn, theo v√†i b·∫°n test th·ª≠ th√¨ ch·ª©c nƒÉng t·∫£i h√¨nh/video tr√™n t∆∞·ªùng ƒë·ªëi t∆∞·ª£ng kh√¥ng ch·∫°y ƒë∆∞·ª£c
// (20/8/2022) TOKEN N√ÄY C√ì TH·ªÇ S·ª¨ D·ª§NG ƒê∆Ø·ª¢C M·ªòT V√ÄI CH·ª®C NƒÇNG
javascript: (function () {
  if (window.location.host !== "www.facebook.com") {
    alert(
      "Bookmark n√†y ch·ªâ d√πng ƒë∆∞·ª£c trong trang www.facebook.com.\nB·∫°n h√£y v√†o trang www.facebook.com v√† ·∫•n l·∫°i bookmark ƒë·ªÉ l·∫•y token nh√©."
    );
    window.open("https://www.facebook.com");
    return;
  }
  var uid = /(?<=c_user=)(\d+)/.exec(document.cookie)[0],
    dtsg =
      require("DTSGInitialData").token ||
      document.querySelector('[name="fb_dtsg"]').value,
    http = new XMLHttpRequest(),
    url = "//www.facebook.com/v1.0/dialog/oauth/confirm",
    params =
      "fb_dtsg=" +
      dtsg +
      "&app_id=124024574287414&redirect_uri=fbconnect%3A%2F%2Fsuccess&display=page&access_token=&from_post=1&return_format=access_token&domain=&sso_device=ios&_CONFIRM=1&_user=" +
      uid;
  http.open("POST", url, !0),
    http.setRequestHeader("Content-type", "application/x-www-form-urlencoded"),
    (http.onreadystatechange = function () {
      if (4 == http.readyState && 200 == http.status) {
        var a = http.responseText.match(/(?<=access_token=)(.*?)(?=\&)/);
        console.log(http.responseText);
        if (a && a[0]) {
          prompt("Token", a[0]);
        } else {
          alert("Failed to Get Access Token.");
        }
      }
    }),
    http.send(params);
})();

// L·∫•y timeline album id c·ªßa page - khi ƒëang trong trang c·ªßa page fb. V√≠ d·ª•: https://www.facebook.com/profile.php?id=100057998562930
javascript: (function () {
  const page_name = document.title;
  const list_a = document.querySelectorAll("a");
  for (let a of Array.from(list_a)) {
    const posts_screen = /(?<=set\=a\.)(.\d+?)(?=\&__cft__)/.exec(a.href);
    if (posts_screen && posts_screen[0]) {
      window.prompt(`Timeline Album ID c·ªßa ${page_name}:`, posts_screen[0]) &&
        window.open("https://www.facebook.com/" + posts_screen[0]);
      return;
    }
  }
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y TIMELINE ALBUM trong trang web!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang web c·ªßa 1 Page fb ch∆∞a?\nTh·ª≠ k√©o xu·ªëng t·ªõi b√†i post n√†o c√≥ k√®m h√¨nh ·∫£nh r·ªìi ·∫•n l·∫°i bookmark nh√©\nTrang web V√≠ d·ª•: ",
    "https://www.facebook.com/profile.php?id=100057998562930"
  );
})();

// L·∫•y user id (uid) - khi ƒëang trong t∆∞·ªùng c·ªßa ng∆∞·ªùi d√πng mu·ªën l·∫•y user id. V√≠ d·ª•: https://www.facebook.com/callchoulnhe
javascript: (function () {
  const user_name = document.title;
  const found = (check) => {
    if (check && check[0]) {
      window.prompt(`USER ID c·ªßa ${user_name}:`, check[0]);
      return true;
    }
    return false;
  };
  if (found(/(?<=\/profile\.php\?id=)(.\d+?)($|(?=&))/.exec(location.href)))
    return;
  const list_a = document.querySelectorAll("a");
  for (let a of Array.from(list_a)) {
    if (found(/(?<=set\=(pb|picfp|ecnf|pob)\.)(.\d+?)($|(?=\.))/.exec(a.href)))
      return;
  }
  if (
    found(
      /(?<=\"user\"\:\{\"id\"\:\")(.\d+?)(?=\")/.exec(document.body.innerHTML)
    )
  )
    return;
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y USER ID n√†o trong trang web!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang profile ch∆∞a?\nTrang web V√≠ d·ª•: ",
    "https://www.facebook.com/callchoulnhe"
  );
})();

// L·∫•y UID t·ª´ url c·ªßa user fb. V√≠ d·ª•: https://www.facebook.com/99.hoangtran
javascript: (function () {
  const getUid = async (url) => {
    var response = await fetch(url);
    if (response.status == 200) {
      var text = await response.text();
      let uid = /(?<=\"userID\"\:\")(.\d+?)(?=\")/.exec(text);
      if (uid?.length) {
        return uid[0];
      }
    }
    return null;
  };
  const url = window.prompt("Nh·∫≠p url c·ªßa user fb:", "");
  if (url)
    getUid(url)
      .then((uid) => {
        if (uid) window.prompt(`UID c·ªßa user ${url}:`, uid);
        else alert("Kh√¥ng t√¨m th·∫•y uid c·ªßa user!");
      })
      .catch((err) => alert("L·ªói: " + err.message));
})();

// L·∫•y group id - tr∆∞·ªùng h·ª£p url c·ªßa group hi·ªÉn th·ªã t√™n ch·ª© ko hi·ªÉn th·ªã id. V√≠ d·ª•: https://www.facebook.com/groups/j2team.community.girls
javascript: (function () {
  const group_name = document.title;
  const found = (check) => {
    if (check && check[0]) {
      window.prompt(`GROUP ID c·ªßa ${group_name}:`, check[0]);
      return true;
    }
    return false;
  };
  if (found(/(?<=\/groups\/)(.\d+?)($|(?=\/)|(?=&))/.exec(location.href)))
    return;
  const list_a = document.querySelectorAll("a");
  for (let a of Array.from(list_a)) {
    if (found(/(?<=\/groups\/)(.\d+?)(?=\/user\/)/.exec(a.href))) return;
  }
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y GROUP ID n√†o trong trang web!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang group ch∆∞a?\nTrang web V√≠ d·ª•:",
    "https://www.facebook.com/groups/j2team.community.girls"
  );
})();

// L·∫•y album id - khi ƒëang xem 1 album, v√≠ d·ª• https://www.facebook.com/media/set/?vanity=ColourfulSpace&set=a.945632905514659
javascript: (function () {
  const list_a = document.querySelectorAll("a");
  for (let a of [location, ...Array.from(list_a)]) {
    const page_album_id = /(?<=\/photos\/a\.)(.\d+?)(?=\/)/.exec(a.href);
    if (page_album_id && page_album_id[0]) {
      window.prompt("PAGE ALBUM ID:", page_album_id[0]);
      return;
    }
    const group_album_id = /(?<=set\=oa\.)(.\d+?)($|(?=&))/.exec(a.href);
    if (group_album_id && group_album_id[0]) {
      window.prompt("GROUP ALBUM ID:", group_album_id[0]);
      return;
    }
    const user_album_id = /(?<=set\=a\.)(.\d+?)($|(?=&))/.exec(a.href);
    if (user_album_id && user_album_id[0]) {
      window.prompt("USER ALBUM ID:", user_album_id[0]);
      return;
    }
  }
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y ALBUM ID n√†o trong trang web!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang album ch∆∞a?\nTrang web V√≠ d·ª•:",
    "https://www.facebook.com/media/set/?vanity=ColourfulSpace&set=a.945632905514659"
  );
})();

// L·∫•y t·∫•t c·∫£ album id c√≥ trong trang web - Khi ƒëang xem 1 danh s√°ch album c·ªßa user/group/page
javascript: (function () {
  const list_a = document.querySelectorAll("a");
  const list_id = [];
  for (let a of [location, ...Array.from(list_a)]) {
    const page_album_id = /(?<=\/photos\/a\.)(.\d+?)(?=\/)/.exec(a.href);
    if (page_album_id && page_album_id[0]) {
      list_id.push(page_album_id[0]);
    }
    const group_album_id = /(?<=set\=oa\.)(.\d+?)($|(?=&))/.exec(a.href);
    if (group_album_id && group_album_id[0]) {
      list_id.push(group_album_id[0]);
    }
    const user_album_id = /(?<=set\=a\.)(.\d+?)($|(?=&))/.exec(a.href);
    if (user_album_id && user_album_id[0]) {
      list_id.push(user_album_id[0]);
    }
  }
  if (list_id.length)
    window.prompt(
      `T√¨m th·∫•y ${list_id.length} album id trong trang web v√† tr√™n url.`,
      list_id.join(", ")
    );
  else
    window.prompt(
      "Kh√¥ng t√¨m th·∫•y ALBUM ID n√†o trong trang web!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang album ch∆∞a?\nTrang web V√≠ d·ª•:",
      "https://www.facebook.com/media/set/?vanity=ColourfulSpace&set=a.945632905514659"
    );
})();

// L·∫•y page id - khi ƒëang trong trang c·ªßa page fb. V√≠ d·ª•: https://www.facebook.com/ColourfulSpace
javascript: (function () {
  const page_name = document.title;
  const found = (check) => {
    if (check && check[0]) {
      window.prompt(`PAGE ID c·ªßa ${page_name}:`, check[0]);
      return true;
    }
    return false;
  };
  if (found(/(?<=\"pageID\"\:\")(.*?)(?=\")/.exec(document.body.innerHTML)))
    return;
  if (found(/(?<=facebook\.com\/)(.*?)($|(?=\/)|(?=&))/.exec(location.href)))
    return;
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y PAGE ID n√†o trong url!\nB·∫°n c√≥ ƒëang ·ªü ƒë√∫ng trang page fb ch∆∞a?\nTrang web V√≠ d·ª•:",
    "https://www.facebook.com/ColourfulSpace"
  );
})();

// L·∫•y t·∫•t c·∫£ uid t·ª´ trang facebook search b·∫°n b√®
// V√≠ d·ª•: https://www.facebook.com/search/people/?q=*a&epa=FILTERS&filters=eyJmcmllbmRzIjoie1wibmFtZVwiOlwidXNlcnNfZnJpZW5kc19vZl9wZW9wbGVcIixcImFyZ3NcIjpcIjEwMDA2NDI2NzYzMjI0MlwifSJ9
// Link tr√™n ƒë∆∞·ª£c t·∫°o t·ª´ web: https://sowsearch.info/
javascript: (() => {
  const getUid = async (url) => {
    var response = await fetch(url);
    if (response.status == 200) {
      var text = await response.text();
      let uid = /(?<=\"userID\"\:\")(.\d+?)(?=\")/.exec(text);
      if (uid?.length) {
        return uid[0];
      }
    }
    return null;
  };

  const main = async () => {
    alert("ƒêang l·∫•y th√¥ng tin uid, m·ªü console ƒë·ªÉ xem ti·∫øn tr√¨nh...");
    let list_a = Array.from(
      document.querySelectorAll(".sjgh65i0 a[role='presentation']")
    );

    let uids = [];
    for (let a of list_a) {
      let l = a.href;

      let uid = l.split("profile.php?id=")[1];
      if (uid) {
        uids.push(uid);
        console.log(uid);
        continue;
      }

      let name = l.split("facebook.com/")[1];
      uid = await getUid(l);
      uids.push(uid);
      console.log(name, uid);
    }
    console.log(uids);
    window.prompt("T·∫•t c·∫£ UID: ", uids.join("\n"));
  };

  main();
})();

// Scroll trang web xu·ªëng cu·ªëi c√πng v√† ch·ªù cho load th√™m, ti·∫øp t·ª•c scroll, cho t·ªõi khi ko c√≤n d·ªØ li·ªáu m·ªõi
javascript: (() => {
  let height = () => document.body.scrollHeight;
  let down = () =>
    window.scrollTo({ left: 0, top: height(), behavior: "smooth" });
  let sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  (async () => {
    let lastScroll = {
      time: Date.now(),
      top: 0,
    };

    while (true) {
      down();

      let currentHeight = height();
      if (currentHeight != lastScroll.top) {
        lastScroll.top = currentHeight;
        lastScroll.time = Date.now();
      } else if (Date.now() - lastScroll.time > 5000) {
        break;
      }
      await sleep(100);
    }
    console.log("end");
  })();
})();

// =====================================================================
// =============================== BONUS ===============================
// =====================================================================

// ƒêƒÉng nh·∫≠p fb b·∫±ng access token: https://tienich.xyz/code-dang-nhap-facebook-bang-access-token-2018/

// L·∫•y t·∫•t c·∫£ video id c√≥ trong trang
javascript: (function () {
  const list_a = document.querySelectorAll("a");
  const list_id = [];
  for (let a of Array.from(list_a)) {
    const check = /(?<=\/videos\/)(.\d+?)($|(?=\/))/.exec(a.href);
    if (check && check[0]) {
      list_id.push(check[0]);
    }
  }
  if (list_id.length)
    window.prompt(`T√¨m th·∫•y ${list_id.length} video id: `, list_id.join(", "));
  else
    window.prompt(
      "Kh√¥ng t√¨m th·∫•y video id n√†o trong trang web!\nB·∫°n c√≥ ·ªü ƒë√∫ng trang video ch∆∞a?\nTrang web v√≠ d·ª•:",
      "https://www.facebook.com/watch/?ref=tab"
    );
})();

// T·∫£i video b·∫±ng video id
javascript: (function () {
  const video_url = window.prompt("Nh·∫≠p video id:");
  if (video_url) {
    window.open("https://mbasic.facebook.com/watch/?v=" + video_url);
  }
})();

// T·∫£i video ƒëang xem - khi ƒëang trong trang web video, d·∫°ng: https://www.facebook.com/watch?v=254222479732213
// N·∫øu b·∫°n mu·ªën t·∫£i HD th√¨ d√πng snapsave: https://snapsave.app/vn
javascript: (function () {
  const found = (check) => {
    if (check && check[0]) {
      const url = window.location.href.replace(
        "www.facebook.com",
        "mbasic.facebook.com"
      );
      window.open(url);
      return true;
    }
    return false;
  };
  if (found(/(?<=\/watch\?v\=)(.\d+?)($|(?=\/))/.exec(location.href))) return;
  if (found(/(?<=videos\/)(.\d+?)($|(?=\/))/.exec(location.href))) return;
  window.prompt(
    "Kh√¥ng t√¨m th·∫•y id c·ªßa video tr√™n url!\nB·∫°n c√≥ ·ªü ƒë√∫ng trang xem video ch∆∞a?\nTrang web v√≠ d·ª•:",
    "https://www.facebook.com/watch?v=254222479732213"
  );
})();

// Chia s·∫ª trang web ƒëang xem l√™n facebook
javascript: !(function () {
  var title = document.title;
  window.open(
    "https://www.facebook.com/sharer/sharer.php?u=" +
      document.URL +
      "&t=" +
      title,
    title,
    "menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=300,width=600"
  );
})();

// L·∫•y t·∫•t c·∫£ id c·ªßa member trong group
// source: https://gist.github.com/thinhbuzz/d8ba04c66f69dc78265b9a9ce5a118c0?fbclid=IwAR37QPDL1zlGWIv_pPq4UydYbFcQKlw7Dio-dP-jtztSJODGPD1RoIGFzZU#file-group-uuid-js-L1
javascript: (function () {
  (async () => {
    function sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function getId() {
      try {
        const props = require("CometRouteStore").getRoute(location.pathname)
          ?.rootView.props;
        const result = require("GroupsCometMembersPageNewMembersSectionRefetchQuery.graphql");
        if (!props || !result) {
          throw new Error("Kh√¥ng ph·∫£i profile");
        }
        return {
          groupID: props.groupID,
          docId: result.params.id,
          method: "ProfileCometAppCollectionPhotosRendererPaginationQuery",
        };
      } catch (e) {
        console.error(e);
      }
      return { groupID: null, docId: null, method: null };
    }

    function prepareData({ dtsg: fb_dtsg, groupID, docId: doc_id, method }) {
      const variables = `{"count":10,"cursor":__CURSOR__,"groupID":"${groupID}","recruitingGroupFilterNonCompliant":false,"scale":1,"id":"${groupID}"}`;
      const data = {
        doc_id,
        fb_dtsg,
        variables,
        fb_api_caller_class: "RelayModern",
        fb_api_req_friendly_name: method,
      };
      const formBody = [];
      for (const property in data) {
        const encodedKey = encodeURIComponent(property);
        const encodedValue = encodeURIComponent(data[property]);
        formBody.push(encodedKey + "=" + encodedValue);
      }
      return formBody.join("&");
    }

    async function getLinks(method, formBody) {
      return fetch("https://www.facebook.com/api/graphql/", {
        headers: {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36",
          "x-fb-friendly-name": method,
        },
        body: formBody,
        method: "POST",
      })
        .then((response) => response.json())
        .then(({ data }) => {
          console.log(data);
          return {
            users: data.node.new_members.edges.map((item) => {
              return {
                id: item.node.id,
                name: item.node.name,
                url: item.node.url,
              };
            }),
            page: data.node.new_members.page_info,
          };
        });
    }

    window.scrollTo(0, document.body.scrollHeight);
    await sleep(1000);
    let cursor = null;
    const limit = +prompt("S·ªë UUID t·ªëi ƒëa s·∫Ω l·∫•y", "999999") || 999999;
    if (!limit) return;

    const { groupID, docId, method } = getId();
    const dtsg = require("DTSG").getCachedToken
      ? require("DTSG").getCachedToken()
      : require("DTSG").getToken();
    window.allItems = [];
    if (!groupID || !docId) {
      throw new Error("Kh√¥ng t√¨m th·∫•y token");
    }
    alert(
      "Qu√° tr√¨nh l·∫•y uuid s·∫Ω di·ªÖn ra trong console.\nNh·∫•n F12 ƒë·ªÉ m·ªü console"
    );
    console.log("%cB·∫Øt ƒë·∫ßu l·∫•y link", "color: green;");
    const formBody = prepareData({ dtsg, groupID, docId, method });
    while (true) {
      let { users, page } = await getLinks(
        method,
        formBody.replace("__CURSOR__", cursor ? `"${cursor}"` : "null")
      );
      window.allItems.push(...users);
      console.log(
        "%cƒê√£ l·∫•y ƒë∆∞·ª£c %d uuid",
        "color: green;",
        window.allItems.length
      );
      if (!page.has_next_page) {
        break;
      }
      cursor = page.end_cursor;
      if (window.allItems.length >= limit) {
        break;
      }
    }
    console.log(window.allItems);
    const styles = ["color: green", "font-size: 20px", "padding: 10px"].join(
      ";"
    );

    console.log(
      "%cƒê√£ l·∫•y th√†nh c√¥ng %d uuid, g√µ copy(window.allItems.map(({ id }) => id).join('\\n')) ƒë·ªÉ sao ch√©p uuid v√†o clipboard",
      styles,
      window.allItems.length
    );
  })().catch((error) => {
    console.log(error);
    alert("Vui l√≤ng t·∫£i l·∫°i trang v√† th·ª≠ l·∫°i.");
  });
})();

```

### scripts\cancellation.js
```js
/**
 * Cancellation System for FB Media Downloader
 * 
 * Allows graceful cancellation of long-running operations by pressing 'q' or 'Esc'.
 * When cancelled, operations complete their current atomic task (e.g., finish downloading
 * the current file) then return to the menu.
 */

import { S } from './constants.js';
import { log } from './logger.js';

// Cancellation state
let cancelled = false;
let keyListenerActive = false;
let originalRawMode = null;

// Key codes
const KEY_Q_LOWER = 'q';
const KEY_Q_UPPER = 'Q';
const KEY_ESC = '\x1B';
const KEY_CTRL_C = '\x03';

/**
 * Custom error class for cancellation
 * This allows us to distinguish cancellation from other errors
 */
export class CancellationError extends Error {
    constructor(message = 'Operation cancelled by user') {
        super(message);
        this.name = 'CancellationError';
    }
}

/**
 * Check if operation has been cancelled
 * @returns {boolean} True if cancelled
 */
export const isCancelled = () => cancelled;

/**
 * Reset cancellation state
 * Call this before starting a new operation
 */
export const resetCancellation = () => {
    cancelled = false;
};

/**
 * Trigger cancellation
 * Called when user presses q or Esc
 */
export const cancel = () => {
    if (!cancelled) {
        cancelled = true;
        log('\n' + S.FgYellow + 'üõë Cancelling... Please wait for current operation to complete.' + S.Reset);
    }
};

/**
 * Handle keypress event
 * @param {Buffer} key - Key data
 */
const handleKeyPress = (key) => {
    const keyStr = key.toString();

    if (keyStr === KEY_Q_LOWER || keyStr === KEY_Q_UPPER || keyStr === KEY_ESC) {
        cancel();
    } else if (keyStr === KEY_CTRL_C) {
        // Still allow Ctrl+C to exit the program entirely
        process.exit(0);
    }
};

/**
 * Start listening for cancellation keys
 * Call this when starting a cancellable operation
 */
export const startCancellableOperation = () => {
    if (keyListenerActive) return;

    resetCancellation();

    // Store original raw mode state
    if (process.stdin.isTTY) {
        originalRawMode = process.stdin.isRaw;

        // Set raw mode to capture individual keypresses
        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.on('data', handleKeyPress);

        keyListenerActive = true;

        // Show hint to user
        log(S.FgCyan + 'üí° Press [q] or [Esc] anytime to cancel and return to menu' + S.Reset + '\n');
    }
};

/**
 * Stop listening for cancellation keys
 * Call this when operation completes or is cancelled
 */
export const stopCancellableOperation = () => {
    if (!keyListenerActive) return;

    // Remove our listener
    process.stdin.removeListener('data', handleKeyPress);

    // Restore original raw mode state
    if (process.stdin.isTTY && originalRawMode !== null) {
        process.stdin.setRawMode(originalRawMode);
    }

    keyListenerActive = false;
};

/**
 * Check cancellation and throw if cancelled
 * Use this at strategic points in loops to enable clean exit
 * @throws {CancellationError} If operation was cancelled
 */
export const throwIfCancelled = () => {
    if (cancelled) {
        throw new CancellationError();
    }
};

/**
 * Wrapper to run a cancellable operation
 * Automatically sets up and tears down the key listener
 * @param {Function} operation - Async function to run
 * @returns {Promise<object>} Result with { result, cancelled }
 */
export const runCancellable = async (operation) => {
    try {
        startCancellableOperation();
        const result = await operation();
        return { result, cancelled: false };
    } catch (error) {
        if (error instanceof CancellationError) {
            log('\n' + S.FgYellow + '‚úÖ Operation cancelled. Returning to menu...' + S.Reset + '\n');
            return { result: null, cancelled: true };
        }
        throw error; // Re-throw non-cancellation errors
    } finally {
        stopCancellableOperation();
    }
};

```

### scripts\constants.js
```js
/**
 * Constants Module for FB Media Downloader
 *
 * Contains API endpoints, media type enums, and console styling codes.
 * @module constants
 */

/**
 * Facebook Graph API base URL with version
 * @constant {string}
 */
export const FB_API_HOST = "https://graph.facebook.com/v21.0";

/**
 * Supported media types for downloads
 * @constant {Object}
 * @property {string} PHOTO - Photo media type
 * @property {string} VIDEO - Video media type
 */
export const MEDIA_TYPE = Object.freeze({
  PHOTO: "photo",
  VIDEO: "video",
});

/**
 * Console text styling codes for terminal output
 * @see https://stackoverflow.com/a/41407246
 * @constant {Object}
 */
export const S = Object.freeze({
  // Reset
  Reset: "\x1b[0m",

  // Text modifiers
  Bright: "\x1b[1m",
  Dim: "\x1b[2m",
  Underscore: "\x1b[4m",
  Blink: "\x1b[5m",
  Reverse: "\x1b[7m",
  Hidden: "\x1b[8m",

  // Foreground colors
  FgBlack: "\x1b[30m",
  FgRed: "\x1b[31m",
  FgGreen: "\x1b[32m",
  FgYellow: "\x1b[33m",
  FgBlue: "\x1b[34m",
  FgMagenta: "\x1b[35m",
  FgCyan: "\x1b[36m",
  FgWhite: "\x1b[37m",

  // Background colors
  BgBlack: "\x1b[40m",
  BgRed: "\x1b[41m",
  BgGreen: "\x1b[42m",
  BgYellow: "\x1b[43m",
  BgBlue: "\x1b[44m",
  BgMagenta: "\x1b[45m",
  BgCyan: "\x1b[46m",
  BgWhite: "\x1b[47m",
});

```

### scripts\database.js
```js
/**
 * Database Module (Legacy Entry Point)
 *
 * This file is maintained for backward compatibility.
 * All functionality has been moved to the database/ subdirectory.
 * 
 * New code should import from './database/index.js' directly.
 * @module database
 * @deprecated Use './database/index.js' instead
 */

// Re-export everything from the new modular structure
export * from './database/index.js';

```

### scripts\download_album.js
```js
import { FB_API_HOST, S } from "./constants.js";
import {
  ACCESS_TOKEN,
  WAIT_BEFORE_NEXT_FETCH,
  ID_LINK_SEPERATOR,
  FOLDER_TO_SAVE_LINKS,
  PHOTO_FILE_FORMAT,
  DATABASE_ENABLED,
  PLATFORM_FACEBOOK,
  getSaveFolderPath,
} from "../config.js";
import {
  createIfNotExistDir,
  deleteFile,
  download,
  getLargestPhotoLink,
  myFetch,
  saveToFile,
  sleep,
} from "./utils.js";
import { t } from "./lang.js";
import { log } from "./logger.js";
import { getOrCreateUser } from "./database.js";
import { checkMediaSkip, attemptHDFetch, saveMediaWithTracking, logDownloadSummary } from "./download_helpers.js";
import { isCancelled } from "./cancellation.js";

/**
 * Fetch album photos from a specific cursor position
 * Returns up to 100 photos per request with their IDs and largest image URLs
 * @param {Object} params - Fetch parameters
 * @param {string} params.albumId - Facebook album ID
 * @param {string|null} params.cursor - Pagination cursor for fetching next page
 * @returns {Promise<{imgData: Array<{id: string, url: string}>, nextCursor: string|null}|null>} Photo data and next cursor, or null on error
 */
const fetchAlbumPhotosFromCursor = async ({ albumId, cursor }) => {
  // create link to fetch
  let url = `${FB_API_HOST}/${albumId}/photos?fields=largest_image&limit=100&access_token=${ACCESS_TOKEN}`;
  if (cursor) url += `&after=${cursor}`;

  const json = await myFetch(url);
  if (!json) return null;

  // return imgData + next cursor
  return {
    imgData: json.data?.map((_) => ({ id: _.id, url: _.largest_image.source })),
    nextCursor: json.paging?.cursors?.after || null,
  };
};

// H√†m n√†y fetch v·ªÅ to√†n b·ªô ·∫£nh t·ª´ 1 album. S·ª≠ d·ª•ng h√†m fetchAlbumPhotosFromCursor
// Li√™n t·ª•c fetch ·∫£nh v√† l·∫•y nextCursor, r·ªìi l·∫°i fetch ·∫£nh ti·∫øp ·ªü cursor m·ªõi. Li√™n t·ª•c cho t·ªõi khi kh√¥ng c√≤n nextCursor
// D·ªØ li·ªáu tr·∫£ v·ªÅ l√† 1 m·∫£ng ch·ª©a d·ªØ li·ªáu {id, url} c·ªßa t·ª´ng ·∫£nh. C√≥ d·∫°ng [{id: .., url: ...}, {id: .., url: ...}, ...]
const fetchAlbumPhotos = async ({
  albumId,
  pageLimit = Infinity,
  fromPhotoId = null, // t·∫£i t·ª´ v·ªã tr√≠ ·∫£nh n√†o ƒë√≥ thay v√¨ t·∫£i t·ª´ ƒë·∫ßu
  pageFetchedCallback = async () => { },
}) => {
  let currentPage = 1;
  let hasNextCursor = true;
  let nextCursor = fromPhotoId
    ? Buffer.from(fromPhotoId).toString("base64")
    : null;
  let allImgsData = [];

  while (hasNextCursor && currentPage <= pageLimit) {
    // Check for cancellation before each page fetch
    if (isCancelled()) {
      log(S.FgYellow + `‚è∏Ô∏è  Stopping at page ${currentPage - 1} (cancelled)` + S.Reset);
      break;
    }

    log(t("downloadingAlbum").replace("{page}", currentPage));

    const data = await fetchAlbumPhotosFromCursor({
      albumId,
      cursor: nextCursor,
    });

    if (data?.imgData) {
      // concat data to result array
      allImgsData.push(...data.imgData);

      log(
        S.BgGreen +
        t("foundAlbumMedia")
          .replace("{length}", data.imgData.length)
          .replace("{total}", allImgsData.length) +
        S.Reset
      );

      // callback when each page fetched
      await pageFetchedCallback(data.imgData);

      // get next cursor AND increase pageNum
      nextCursor = data.nextCursor;
      hasNextCursor = nextCursor != null;
      currentPage++;

      // wait for next fetch - if needed
      if (WAIT_BEFORE_NEXT_FETCH) {
        log(t("pausing").replace("{ms}", WAIT_BEFORE_NEXT_FETCH));
        await sleep(WAIT_BEFORE_NEXT_FETCH);
      }
    } else {
      // FAILED => re-fetch currentPage
      log(S.BgRed + "[!] ERROR." + S.Reset);
      break;
    }
  }

  return allImgsData;
};

/**
 * Fetch album information including owner details
 * @param {string} albumId - Facebook album ID
 * @returns {Promise<{id: string, count: number, link: string, name: string, ownerId: string|null}|null>} Album info or null on error
 */
export const fetchAlbumInfo = async (albumId) => {
  // create link to fetch - now includes 'from' field to get owner info
  let url = `${FB_API_HOST}/${albumId}?fields=id,from,name,type,count,link&access_token=${ACCESS_TOKEN}`;

  // fetch data
  const json = await myFetch(url);

  // return album infomation
  if (!json) return null;
  return {
    id: albumId,
    count: json.count,
    link: json.link,
    name: json.name,
    ownerId: json.from?.id || null, // Owner's user ID for unified storage
  };
};

/**
 * Download and save all photo links from an album to a text file
 * Saves IDs and URLs in the links folder for later use
 * @param {Object} params - Download parameters
 * @param {string} params.albumId - Facebook album ID
 * @param {string|null} params.fromPhotoId - Start from this photo ID (optional)
 * @param {boolean} params.isGetLargestPhoto - Whether to fetch HD versions (default: false)
 * @returns {Promise<void>}
 */
export const downloadAlbumPhotoLinks = async ({
  albumId,
  fromPhotoId,
  isGetLargestPhoto = false,
}) => {
  const from_text = fromPhotoId
    ? t("fromPhotoID") + fromPhotoId
    : t("fromBeginAlbum");
  log(t("downloadAlbumFrom").replace("{albumId}", albumId) + `${from_text}...`);

  const fileName = `${FOLDER_TO_SAVE_LINKS}/${albumId}.txt`;
  deleteFile(fileName); // delete if file exist

  await fetchAlbumPhotos({
    albumId,
    fromPhotoId,
    pageFetchedCallback: (pageImgsData) => {
      log(`ƒêang l∆∞u link v√†o file ${fileName}`);

      if (isGetLargestPhoto) {
        // TODO  gett largest photo link
      }

      saveToFile(
        fileName,
        pageImgsData.map((_) => _.id + ID_LINK_SEPERATOR + _.url).join("\n"),
        false
      );
    },
  });
};

/**
 * Download and save all photos from an album to disk
 * Saves photos in the owner's photos folder with optional HD quality
 * @param {Object} params - Download parameters
 * @param {string} params.albumId - Facebook album ID
 * @param {string|null} params.fromPhotoId - Start from this photo ID (optional)
 * @param {boolean} params.isGetLargestPhoto - Whether to fetch HD versions (default: false)
 * @returns {Promise<{saved: number, skipped: number}>} Download statistics
 */
export const downloadAlbumPhoto = async ({
  albumId,
  fromPhotoId,
  isGetLargestPhoto = false,
}) => {
  const from_text = fromPhotoId
    ? t("fromPhotoID") + fromPhotoId
    : t("fromBeginAlbum");
  log(t("downloadAlbumFrom").replace("{albumId}", albumId) + `${from_text}...`);

  // Get album info to find owner ID
  const albumInfo = await fetchAlbumInfo(albumId);
  const ownerId = albumInfo?.ownerId;

  if (!ownerId) {
    log(S.BgRed + "Could not determine album owner. Using albumId for folder." + S.Reset);
  }

  const targetId = ownerId || albumId; // Use owner ID if available, fallback to album ID

  // Get or create user in database
  const userId = DATABASE_ENABLED && ownerId ? getOrCreateUser(PLATFORM_FACEBOOK, ownerId) : null;

  let saved = 0;
  let skipped = 0;

  await fetchAlbumPhotos({
    albumId,
    fromPhotoId,
    pageFetchedCallback: async (pageImgsData) => {
      // Use unified folder structure: downloads/{ownerId}/photos/
      const dir = getSaveFolderPath(targetId, 'photos');
      createIfNotExistDir(dir);

      // save all photo to directory
      for (let data of pageImgsData) {
        let { id: photo_id, url: photo_url } = data;

        const savePath = `${dir}/${photo_id}.${PHOTO_FILE_FORMAT}`;

        // Smart skip: check DB status for HD upgrade
        const skipCheck = checkMediaSkip(userId, photo_id, isGetLargestPhoto);

        if (skipCheck.skip) {
          log(`‚è≠Ô∏è  SKIPPING ${photo_id} (${skipCheck.reason})`);
          skipped++;
          continue;
        }

        if (skipCheck.needsUpgrade) {
          log(`üîÑ UPGRADE ${photo_id} to HD (was SD)`);
        }

        let isHdDownload = false;
        if (isGetLargestPhoto) {
          const hdResult = await attemptHDFetch(photo_id, userId, skipCheck.needsUpgrade);

          if (hdResult.shouldSkip) {
            log(`‚è≠Ô∏è  SKIPPING ${photo_id} (HD fetch failed, keeping SD version)`);
            skipped++;
            continue;
          }

          if (hdResult.url) {
            photo_url = hdResult.url;
            isHdDownload = true;
          }
        }

        try {
          log(
            t("saving").replace("{count}", saved).replace("{path}", savePath)
          );
          await download(photo_url, savePath);

          // Mark as downloaded in database with HD status
          saveMediaWithTracking(userId, photo_id, isHdDownload, savePath, skipCheck.needsUpgrade);

          saved++;
        } catch (e) {
          log(
            S.BgRed + t("errorWhenSave").replace("{path}", savePath) + S.Reset,
            e.toString()
          );
        }
      }
    },
  });

  // Log summary
  logDownloadSummary({ saved, skipped, mediaType: 'photos' });

  return { saved, skipped };
};

```

### scripts\download_helpers.js
```js
import { DATABASE_ENABLED, WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO } from "../config.js";
import { getMediaStatus, saveMedia, updateMediaToHD } from "./database.js";
import { getLargestPhotoLink, sleep } from "./utils.js";
import { t } from "./lang.js";
import { log } from "./logger.js";

/**
 * Check if media should be skipped based on database status
 * @param {number|null} userId - Database user ID
 * @param {string} mediaId - Media ID
 * @param {boolean} isGetLargestPhoto - Whether HD mode is enabled
 * @returns {object} { skip: boolean, reason: string, needsUpgrade: boolean, mediaStatus: object|null }
 */
export const checkMediaSkip = (userId, mediaId, isGetLargestPhoto = false) => {
    if (!DATABASE_ENABLED || !userId) {
        return { skip: false, reason: null, needsUpgrade: false, mediaStatus: null };
    }

    const mediaStatus = getMediaStatus(userId, mediaId);

    if (!mediaStatus?.exists) {
        return { skip: false, reason: null, needsUpgrade: false, mediaStatus };
    }

    // Check if we need HD upgrade
    if (isGetLargestPhoto && !mediaStatus.isHd) {
        return {
            skip: false,
            reason: null,
            needsUpgrade: true,
            mediaStatus
        };
    }

    // Already downloaded (and HD if requested)
    return {
        skip: true,
        reason: `already downloaded${mediaStatus.isHd ? ', HD' : ''}`,
        needsUpgrade: false,
        mediaStatus
    };
};

/**
 * Attempt to get HD version of a photo
 * @param {string} mediaId - Photo ID
 * @param {number|null} userId - Database user ID
 * @param {boolean} isUpgradeAttempt - Whether this is upgrading an existing SD photo
 * @returns {Promise<object>} { url: string|null, isHd: boolean, shouldSkip: boolean }
 */
export const attemptHDFetch = async (mediaId, userId, isUpgradeAttempt = false) => {
    await sleep(WAIT_BEFORE_NEXT_FETCH_LARGEST_PHOTO);
    log(t("fetchingHDPhoto").replace("{media_id}", mediaId).replace("media_id", mediaId));

    const hdUrl = await getLargestPhotoLink(mediaId);

    if (hdUrl) {
        return { url: hdUrl, isHd: true, shouldSkip: false };
    }

    // HD fetch failed
    if (isUpgradeAttempt) {
        // We already have SD version, skip re-download
        return { url: null, isHd: false, shouldSkip: true };
    }

    // No HD available, but we can still download SD
    return { url: null, isHd: false, shouldSkip: false };
};

/**
 * Save media to database with proper HD tracking
 * @param {number|null} userId - Database user ID
 * @param {string} mediaId - Media ID
 * @param {boolean} isHd - Whether media was downloaded in HD
 * @param {string} savePath - Path where file is saved
 * @param {boolean} wasUpgrade - Whether this was an upgrade from SD to HD
 */
export const saveMediaWithTracking = (userId, mediaId, isHd, savePath, wasUpgrade = false) => {
    if (!DATABASE_ENABLED || !userId) return;

    const existingStatus = getMediaStatus(userId, mediaId);

    if (existingStatus?.exists) {
        // Only update to HD if HD fetch actually succeeded
        if (isHd) {
            updateMediaToHD(userId, mediaId, savePath);
        }
        // If HD fetch failed, leave the record as-is (still SD)
    } else {
        // New media
        saveMedia(userId, mediaId, isHd, savePath);
    }
};

/**
 * Log download summary in consistent format
 * @param {object} stats - Download statistics
 * @param {number} stats.savedPhotos - Number of photos saved
 * @param {number} stats.savedVideos - Number of videos saved  
 * @param {number} stats.skippedPhotos - Number of photos skipped
 * @param {number} stats.skippedVideos - Number of videos skipped
 * @param {number} stats.saved - Total items saved (for single media type)
 * @param {number} stats.skipped - Total items skipped (for single media type)
 * @param {string} stats.mediaType - Type of media: 'photos', 'videos', or 'media'
 */
export const logDownloadSummary = (stats) => {
    const {
        savedPhotos,
        savedVideos,
        skippedPhotos,
        skippedVideos,
        saved,
        skipped,
        mediaType = 'media'
    } = stats;

    if (savedPhotos !== undefined && savedVideos !== undefined) {
        // Mixed media (wall)
        log(`\nüìä Summary: ${savedPhotos} photos, ${savedVideos} videos saved | ${skippedPhotos || 0} photos, ${skippedVideos || 0} videos skipped (duplicates)`);
    } else {
        // Single media type
        log(`\nüìä Summary: ${saved} ${mediaType} saved, ${skipped} skipped (duplicates)`);
    }
};

```

### scripts\download_timeline_album.js
```js
/**
 * Timeline Album Download Module
 *
 * Timeline Albums contain all photos posted to a Facebook Page.
 * These albums are hidden on Facebook's UI but accessible via Graph API.
 * @module download_timeline_album
 */

import { FB_API_HOST } from "./constants.js";
import { ACCESS_TOKEN } from "../config.js";
import {
  downloadAlbumPhoto,
  downloadAlbumPhotoLinks,
} from "./download_album.js";
import { myFetch } from "./utils.js";
import { t } from "./lang.js";
import { log } from "./logger.js";

/**
 * Fetch the Timeline Album ID for a Facebook Page
 * Searches through the page's albums to find the one with type "wall"
 * @param {string} page_id - Facebook Page ID
 * @returns {Promise<string|null>} Timeline album ID or null if not found
 */
export const fetchTimeLineAlbumId_FBPage = async (page_id) => {
  // create link to fetch all albums of page
  const url = `${FB_API_HOST}/${page_id}/albums?fields=type&limit=100&access_token=${ACCESS_TOKEN}`;

  // fetch data
  const json = await myFetch(url);
  if (!json) return null;

  // find timeline album
  const timeLineAlbum = json.data.find((_) => _.type === "wall");

  // return id (or null if not found timeline album)
  return timeLineAlbum?.id;
};

/**
 * Download all photo links from a Page's Timeline Album to a text file
 * @param {Object} params - Download parameters
 * @param {string} params.page_id - Facebook Page ID
 * @param {string|null} params.fromPhotoId - Start from this photo ID (optional)
 * @returns {Promise<void>}
 */
export const downloadTimeLineAlbumPhotoLinks_FBPage = async ({
  page_id,
  fromPhotoId,
}) => {
  const album_id = await fetchTimeLineAlbumId_FBPage(page_id);
  if (album_id) {
    log(t("foundTimelineAlbumID"), album_id);
    await downloadAlbumPhotoLinks({ albumId: album_id, fromPhotoId });
  } else {
    console.error(t("pageDontHaveTimelineAlbum"));
  }
};

/**
 * Download all photos from a Page's Timeline Album to disk
 * @param {Object} params - Download parameters
 * @param {string} params.page_id - Facebook Page ID
 * @param {string|null} params.fromPhotoId - Start from this photo ID (optional)
 * @returns {Promise<void>}
 */
export const downloadTimeLineAlbum_FBPage = async ({
  page_id,
  fromPhotoId,
}) => {
  const album_id = await fetchTimeLineAlbumId_FBPage(page_id);
  if (album_id) {
    log(t("foundTimelineAlbumID"), album_id);
    await downloadAlbumPhoto({ albumId: album_id, fromPhotoId });
  } else {
    console.error(t("pageDontHaveTimelineAlbum"));
  }
};

```

### scripts\download_user_photos.js
```js
import {
  ACCESS_TOKEN,
  PHOTO_FILE_FORMAT,
  WAIT_BEFORE_NEXT_FETCH,
  DATABASE_ENABLED,
  PLATFORM_FACEBOOK,
  getSaveFolderPath,
} from "../config.js";
import { FB_API_HOST, S } from "./constants.js";
import { t } from "./lang.js";
import { log } from "./logger.js";
import { createIfNotExistDir, download, myFetch, sleep, sanitizeFolderName, saveCaptionFile } from "./utils.js";
import { getOrCreateUser, saveMedia } from "./database.js";
import { checkMediaSkip, logDownloadSummary } from "./download_helpers.js";
import { runBatchDownload } from "./batch_utils.js";
import { isCancelled, throwIfCancelled } from "./cancellation.js";

/**
 * Fetch user's uploaded photos with pagination support
 * Retrieves photos with album info and largest image URLs
 * @param {Object} params - Fetch parameters
 * @param {string} params.targetId - Facebook user ID
 * @param {number} params.pageLimit - Maximum number of pages to fetch (default: Infinity)
 * @param {string|null} params.fromCursor - Pagination cursor to start from
 * @param {Function} params.pageFetchedCallback - Callback called after each page is fetched
 * @returns {Promise<Array>} Array of all fetched photos with metadata
 */
const fetchUserPhotos = async ({
  targetId,
  pageLimit = Infinity,
  fromCursor,
  pageFetchedCallback = () => { },
}) => {
  const all_photos = [];
  let page = 1;
  let url = `${FB_API_HOST}/${targetId}/photos?type=uploaded&fields=largest_image,name,album&access_token=${ACCESS_TOKEN}`;

  if (fromCursor) {
    url += "&after=" + fromCursor;
  }

  while (url && page <= pageLimit) {
    // Check for cancellation before each page fetch
    if (isCancelled()) {
      log(S.FgYellow + `‚è∏Ô∏è  Stopping at page ${page - 1} (cancelled)` + S.Reset);
      break;
    }

    log(t("downloadingPage").replace("{page}", page));
    const fetchData = await myFetch(url);
    page++;

    if (!fetchData?.data) break;

    const photos = fetchData.data;
    all_photos.push(...photos);
    log(`> T√åM TH·∫§Y ${photos.length} ·∫£nh. (T·ªîNG: ${all_photos.length})`);
    log(t("currentPageID"), fetchData.paging?.cursors?.before);
    log(t("nextPageID"), fetchData.paging?.cursors?.after, "\n");

    // callback when each page fetched
    await pageFetchedCallback(photos);

    // get next paging
    url = fetchData?.paging?.next;

    // wait for next fetch - if needed
    if (WAIT_BEFORE_NEXT_FETCH) {
      log(t("pausing").replace("{ms}", WAIT_BEFORE_NEXT_FETCH));
      await sleep(WAIT_BEFORE_NEXT_FETCH);
    }
  }

  return all_photos;
};

/**
 * Download all uploaded photos from a user's profile
 * Organizes photos by album in the user's photos folder
 * @param {Object} params - Download parameters
 * @param {string} params.targetId - Facebook user ID
 * @param {string|null} params.fromCursor - Pagination cursor to resume from
 * @param {number} params.pageLimit - Maximum number of pages to fetch (default: Infinity)
 * @returns {Promise<{saved: number, skipped: number}>} Download statistics
 */
export const downloadUserPhotos = async ({
  targetId,
  fromCursor,
  pageLimit = Infinity,
}) => {
  log(t("downloadingUserImage").replace("{user_id}", targetId));
  let saved = 0;
  let skipped = 0;

  // Get or create user in database
  const userId = DATABASE_ENABLED ? getOrCreateUser(PLATFORM_FACEBOOK, targetId) : null;

  await fetchUserPhotos({
    targetId,
    fromCursor,
    pageLimit,
    pageFetchedCallback: async (photos) => {
      // save all photos to directory
      for (let data of photos) {
        const { largest_image, name, album, id } = data;

        // Organize by album: downloads/{userId}/photos/{albumName}/
        const albumName = album?.name ? sanitizeFolderName(album.name) : '(no album)';
        const baseDir = getSaveFolderPath(targetId, 'photos');
        const albumDir = `${baseDir}/${albumName}`;
        const savePath = `${albumDir}/${id}.${PHOTO_FILE_FORMAT}`;

        // Smart skip: check DB status only
        const skipCheck = checkMediaSkip(userId, id, false);
        if (skipCheck.skip) {
          log(`‚è≠Ô∏è  SKIPPING ${id} (${skipCheck.reason})`);
          skipped++;
          continue;
        }

        createIfNotExistDir(albumDir);

        try {
          const moreInfo = `[${album?.name || 'No album'}] [${name || ""}]`;

          log(
            t("savingUserMedia")
              .replace("{count}", saved)
              .replace("{path}", savePath)
              .replace("{moreInfo}", moreInfo)
          );
          await download(largest_image.source, savePath);

          // Save caption as text file if exists
          if (name) {
            saveCaptionFile(`${albumDir}/${id}`, name);
          }

          // Mark as downloaded in database (photos from user_photos endpoint include largest_image, so HD)
          if (DATABASE_ENABLED && userId) {
            saveMedia(userId, id, true, savePath);
          }

          saved++;
        } catch (e) {
          log(
            S.BgRed + t("errorWhenSave").replace("{path}", savePath) + S.Reset,
            e.toString()
          );
        }
      }
    },
  });

  // Log summary
  logDownloadSummary({ saved, skipped, mediaType: 'photos' });

  return { saved, skipped };
};

/**
 * Batch download photos from multiple users
 * Uses runBatchDownload for consistent progress reporting
 * @param {string[]} userIds - Array of Facebook user IDs
 * @param {Object} options - Download options (fromCursor, pageLimit)
 * @returns {Promise<Array>} Array of results for each user
 */
export const downloadUserPhotosBatch = async (userIds, options) => {
  return runBatchDownload(userIds, downloadUserPhotos, options, {
    mediaType: 'photos'
  });
};

```

### scripts\download_user_videos.js
```js
import {
  ACCESS_TOKEN,
  VIDEO_FILE_FORMAT,
  WAIT_BEFORE_NEXT_FETCH,
  DATABASE_ENABLED,
  PLATFORM_FACEBOOK,
  getSaveFolderPath,
} from "../config.js";
import { FB_API_HOST, S } from "./constants.js";
import { t } from "./lang.js";
import { log } from "./logger.js";
import { createIfNotExistDir, download, myFetch, sleep, saveCaptionFile } from "./utils.js";
import { getOrCreateUser, saveMedia } from "./database.js";
import { checkMediaSkip, logDownloadSummary } from "./download_helpers.js";
import { runBatchDownload } from "./batch_utils.js";
import { isCancelled } from "./cancellation.js";

/**
 * Extract video information from a post attachment
 * Handles video types and recursively processes album sub-attachments
 * @param {Object} attachment - Facebook post attachment object
 * @param {string} attachment.type - Attachment type (video_autoplay, video_inline, video, album)
 * @param {Object} attachment.target - Target object containing video ID
 * @param {Object} attachment.media - Media object containing video source URL
 * @param {Object} attachment.subattachments - Sub-attachments for albums
 * @returns {Array<{id: string, source: string, description: string, has_hd_quality: boolean}>} Array of video data
 */
const getVideoFromAttachment = (attachment) => {
  const videos = [];
  const type = attachment?.type;
  const id = attachment?.target?.id;

  if (!type) return videos;

  // Handle video types
  if (type === "video_autoplay" || type === "video_inline" || type === "video") {
    if (id && attachment.media?.source) {
      videos.push({
        id: id,
        source: attachment.media.source,
        description: attachment.description || "",
        // Estimate quality from URL or default to SD
        has_hd_quality: attachment.media.source?.includes("hd") || false,
      });
    }
  }

  // Handle albums (may contain videos)
  if (type === "album" && attachment?.subattachments?.data) {
    attachment.subattachments.data.forEach((sub) => {
      videos.push(...getVideoFromAttachment(sub));
    });
  }

  return videos;
};

/**
 * Fetch user's videos from their feed with pagination support
 * Uses feed endpoint with attachments to bypass permission restrictions
 * @param {Object} params - Fetch parameters
 * @param {string} params.targetId - Facebook user ID
 * @param {number} params.pageLimit - Maximum number of pages to fetch (default: Infinity)
 * @param {string|null} params.fromCursor - Pagination cursor to start from
 * @param {Function} params.pageFetchedCallback - Callback called after each page is fetched
 * @returns {Promise<Array>} Array of all fetched videos with metadata
 */
const fetchUserVideos = async ({
  targetId,
  pageLimit = Infinity,
  fromCursor,
  pageFetchedCallback = () => { },
}) => {
  const all_videos = [];
  let page = 1;

  // Use feed endpoint with attachments - works for any user's public posts
  // This bypasses the Permission Denied error from /{user-id}/videos endpoint
  let url = `${FB_API_HOST}/${targetId}/feed?fields=attachments{media,type,subattachments,target,description}&access_token=${ACCESS_TOKEN}`;

  if (fromCursor) {
    url += "&after=" + fromCursor;
  }

  while (url && page <= pageLimit) {
    // Check for cancellation before each page fetch
    if (isCancelled()) {
      log(S.FgYellow + `‚è∏Ô∏è  Stopping at page ${page - 1} (cancelled)` + S.Reset);
      break;
    }

    log(t("downloadingPage").replace("{page}", page));
    const fetchData = await myFetch(url);
    page++;

    if (!fetchData?.data) break;

    // Extract videos from post attachments
    const videos = [];
    fetchData.data.forEach((post) => {
      if (post.attachments?.data) {
        post.attachments.data.forEach((attachment) => {
          videos.push(...getVideoFromAttachment(attachment));
        });
      }
    });

    if (videos.length > 0) {
      all_videos.push(...videos);
      log(
        t("foundVideos")
          .replace("{length}", videos.length)
          .replace("{total}", all_videos.length)
      );
      log(t("currentPageID"), fetchData.paging?.cursors?.before);
      log(t("nextPageID"), fetchData.paging?.cursors?.after, "\n");

      // callback when each page fetched
      await pageFetchedCallback(videos);
    } else {
      log(`> Trang ${page - 1}: Kh√¥ng t√¨m th·∫•y video n√†o.`);
    }

    // get next paging
    url = fetchData?.paging?.next;

    // wait for next fetch - if needed
    if (WAIT_BEFORE_NEXT_FETCH) {
      log(t("pausing").replace("{ms}", WAIT_BEFORE_NEXT_FETCH));
      await sleep(WAIT_BEFORE_NEXT_FETCH);
    }
  }

  return all_videos;
};

/**
 * Download all videos from a user's feed
 * Saves videos in the user's videos folder with descriptions
 * @param {Object} params - Download parameters
 * @param {string} params.targetId - Facebook user ID
 * @param {string|null} params.fromCursor - Pagination cursor to resume from
 * @param {number} params.pageLimit - Maximum number of pages to fetch (default: Infinity)
 * @returns {Promise<{saved: number, skipped: number}>} Download statistics
 */
export const downloadUserVideos = async ({
  targetId,
  fromCursor,
  pageLimit = Infinity,
}) => {
  log(t("downloadingUserVideo").replace("{user_id}", targetId));
  let saved = 0;
  let skipped = 0;

  // Get or create user in database
  const userId = DATABASE_ENABLED ? getOrCreateUser(PLATFORM_FACEBOOK, targetId) : null;

  await fetchUserVideos({
    targetId,
    fromCursor,
    pageLimit,
    pageFetchedCallback: async (videos) => {
      // Use unified folder structure: downloads/{userId}/videos/
      const dir = getSaveFolderPath(targetId, 'videos');
      createIfNotExistDir(dir);

      // save all videos to directory
      for (let data of videos) {
        const {
          source,
          id,
          description,
          has_hd_quality,
        } = data;

        const url = source;
        const savePath = `${dir}/${id}.${VIDEO_FILE_FORMAT}`;

        // Smart skip: check DB status only
        const skipCheck = checkMediaSkip(userId, id, false);
        if (skipCheck.skip) {
          log(`‚è≠Ô∏è  SKIPPING ${id} (${skipCheck.reason})`);
          skipped++;
          continue;
        }

        try {
          const moreInfo =
            (has_hd_quality ? "[HD]" : "[sd]") +
            (description ? ` [${description}]` : "");

          log(
            t("savingUserMedia")
              .replace("{count}", saved)
              .replace("{path}", savePath)
              .replace("{moreInfo}", moreInfo)
          );
          await download(url, savePath);

          // Save description as text file if exists
          if (description) {
            saveCaptionFile(`${dir}/${id}`, description);
          }

          // Mark as downloaded in database (videos are always considered HD)
          if (DATABASE_ENABLED && userId) {
            saveMedia(userId, id, true, savePath);
          }

          saved++;
        } catch (e) {
          log(
            S.BgRed + t("errorWhenSave").replace("{path}", savePath) + S.Reset,
            e.toString()
          );
        }
      }
    },
  });

  // Log summary
  logDownloadSummary({ saved, skipped, mediaType: 'videos' });

  return { saved, skipped };
};

/**
 * Batch download videos from multiple users
 * Uses runBatchDownload for consistent progress reporting
 * @param {string[]} userIds - Array of Facebook user IDs
 * @param {Object} options - Download options (fromCursor, pageLimit)
 * @returns {Promise<Array>} Array of results for each user
 */
export const downloadUserVideosBatch = async (userIds, options) => {
  return runBatchDownload(userIds, downloadUserVideos, options, {
    mediaType: 'videos'
  });
};

```

### scripts\download_wall_media.js
```js
import { FB_API_HOST, MEDIA_TYPE, S } from "./constants.js";
import {
  ACCESS_TOKEN,
  FOLDER_TO_SAVE_LINKS,
  ID_LINK_SEPERATOR,
  PHOTO_FILE_FORMAT,
  VIDEO_FILE_FORMAT,
  WAIT_BEFORE_NEXT_FETCH,
  DATABASE_ENABLED,
  PLATFORM_FACEBOOK,
  getSaveFolderPath,
} from "../config.js";
import {
  createIfNotExistDir,
  deleteFile,
  download,
  getLargestPhotoLink,
  myFetch,
  saveToFile,
  sleep,
} from "./utils.js";
import { t } from "./lang.js";
import { log } from "./logger.js";
import { getOrCreateUser } from "./database.js";
import { checkMediaSkip, attemptHDFetch, saveMediaWithTracking, logDownloadSummary } from "./download_helpers.js";
import { runBatchDownload } from "./batch_utils.js";
import { isCancelled } from "./cancellation.js";

/**
 * Extract media (photos/videos) from a Facebook post attachment
 * Handles photo, video, and album attachment types recursively
 * @param {Object} attachment - Facebook attachment object from feed API
 * @param {string} attachment.type - Attachment type (photo, video_autoplay, video_inline, video, album)
 * @param {Object} attachment.target - Target object containing media ID
 * @param {Object} attachment.media - Media object with image/video data
 * @param {Object} attachment.subattachments - Sub-attachments for album types
 * @returns {Array<{type: string, id: string, url: string}>} Array of extracted media items
 */
const getMediaFromAttachment = (attachment) => {
  const filtered_media = [];

  let id = attachment?.target?.id;
  let type = attachment?.type;

  if (!id || !type) return filtered_media;

  /*
    Attachment LO·∫†I PHOTO c√≥ c·∫•u tr√∫c nh∆∞ sau
    {
        "media": {
            "image": {
                "height": 720,
                "src": "https://scontent.fhan2-4.fna.fbcdn.net/v/t39.30808-6/p480x480/233193975_582887376210934_3917501890611553539_n.jpg?_nc_cat=103&ccb=1-5&_nc_sid=07e735&_nc_ohc=b2Z1BxAj3PwAX_a0j-F&_nc_ht=scontent.fhan2-4.fna&oh=1100b63609d1d331a0a17721b002ae78&oe=614A6EAD",
                "width": 480
            }
        },
        "target": {
            "id": "582887366210935",
            "url": "https://www.facebook.com/photo.php?fbid=582887366210935&set=gm.1020873538672374&type=3"
        },
        "type": "photo",
        "url": "https://www.facebook.com/photo.php?fbid=582887366210935&set=gm.1020873538672374&type=3"
    }*/
  if (type === "photo") {
    filtered_media.push({
      type: MEDIA_TYPE.PHOTO,
      id: id,
      url: attachment.media.image.src,
    });
  }

  /*
    Attachment LO·∫†I VIDEO_AUTOPLAY, VIDEO_INLINE, VIDEO c√≥ ƒë·ªãnh d·∫°ng nh∆∞ sau
    {
        "media": {
            "image": {
                "height": 720,
                "src": "https://scontent.fsgn2-4.fna.fbcdn.net/v/t15.5256-10/s720x720/241870607_843209866352821_4272847571535179706_n.jpg?_nc_cat=101&ccb=1-5&_nc_sid=ad6a45&_nc_ohc=Ap2YChXA4fUAX_RgBT7&_nc_ht=scontent.fsgn2-4.fna&oh=f9fcc65d6c8a53207c1d03b19d036503&oe=614B4EE9",
                "width": 405
            },
            "source": "https://video.fsgn2-6.fna.fbcdn.net/v/t42.1790-2/241979905_562868464766358_5763545655575200708_n.mp4?_nc_cat=110&ccb=1-5&_nc_sid=985c63&efg=eyJybHIiOjM5MiwicmxhIjo1MTIsInZlbmNvZGVfdGFnIjoic3ZlX3NkIn0%3D&_nc_ohc=1vx2K2s8m1IAX8TzDPs&rl=392&vabr=218&_nc_ht=video.fsgn2-6.fna&oh=32df5af4a31f119a16ca4fb8d30b48f0&oe=61477791"
        },
        "target": {
            "id": "843209423019532",
            "url": "https://www.facebook.com/groups/j2team.community.girls/permalink/1045907852835609/"
        },
        "type": "video_autoplay",
        "url": "https://www.facebook.com/groups/j2team.community.girls/permalink/1045907852835609/"
    } */
  if (
    type === "video_autoplay" ||
    type === "video_inline" ||
    type === "video"
  ) {
    filtered_media.push({
      type: MEDIA_TYPE.VIDEO,
      id: id,
      url: attachment.media.source,
    });
  }

  /*
    Attachment LO·∫†I ALBUM c√≥ ƒë·ªãnh d·∫°ng nh∆∞ sau
    {
        "media": {
            "image": {
                "height": 720,
                "src": "https://scontent.fhan2-4.fna.fbcdn.net/v/t39.30808-6/p480x480/233193975_582887376210934_3917501890611553539_n.jpg?_nc_cat=103&ccb=1-5&_nc_sid=07e735&_nc_ohc=b2Z1BxAj3PwAX_a0j-F&_nc_ht=scontent.fhan2-4.fna&oh=1100b63609d1d331a0a17721b002ae78&oe=614A6EAD",
                "width": 480
            }
        },
        "subattachments": {
            "data": [
                {sub_attachment_1}, // C√°c sub attachment n√†y c√≥ c·∫•u tr√∫c gi·ªëng attachment PHOTO ho·∫∑c VIDEO_AUTOPLAY
                {sub_attachment_2},
                ...
            ]
        },
        "target": {
            "id": "1020873538672374",
            "url": "https://www.facebook.com/media/set/?set=pcb.1020873538672374&type=1"
        },
        "title": "Photos from L√™ T√†i's post",
        "type": "album",
        "url": "https://www.facebook.com/media/set/?set=pcb.1020873538672374&type=1"
    } */
  if (type === "album") {
    // G·ªåI ƒê·ªÜ QUY V·ªöI T·ª™NG SUB_ATTACHMENT
    attachment?.subattachments?.data?.forEach((sub) => {
      filtered_media.push(...getMediaFromAttachment(sub));
    });
  }

  return filtered_media;
};

/**
 * Fetch all media from a user's wall/feed with pagination
 * Retrieves photos and videos from post attachments
 * @param {Object} params - Fetch parameters
 * @param {string} params.targetId - Facebook user/page/group ID
 * @param {number} params.pageLimit - Maximum number of pages to fetch (default: Infinity)
 * @param {Function} params.pageFetchedCallback - Callback called after each page with media array
 * @returns {Promise<Array<{type: string, id: string, url: string}>>} Array of all fetched media
 */
const fetchWallMedia = async ({
  targetId,
  pageLimit = Infinity,
  pageFetchedCallback = () => { },
}) => {
  const all_media = []; // store all media {id, url, type}
  let page = 1;
  let url = `${FB_API_HOST}/${targetId}/feed?fields=attachments{media,type,subattachments,target}&access_token=${ACCESS_TOKEN}`;

  while (url && page <= pageLimit) {
    // Check for cancellation before each page fetch
    if (isCancelled()) {
      log(S.FgYellow + `‚è∏Ô∏è  Stopping at page ${page - 1} (cancelled)` + S.Reset);
      break;
    }

    log(t("downloadingPage").replace("{page}", page));
    const fetchData = await myFetch(url);
    page++;

    if (fetchData?.data) {
      // Get all media from each attachment
      const media = [];
      fetchData.data.forEach((feedData) => {
        feedData.attachments?.data.forEach((at) => {
          media.push(...getMediaFromAttachment(at));
        });
      });

      all_media.push(...media);
      log(
        t("foundWallMedia")
          .replace("{length}", media.length)
          .replace("{total}", all_media.length)
      );

      // callback when each page fetched
      await pageFetchedCallback(media);

      // get next paging
      url = fetchData?.paging?.next;

      // wait for next fetch - if needed
      if (WAIT_BEFORE_NEXT_FETCH) {
        log(t("pausing").replace("{ms}", WAIT_BEFORE_NEXT_FETCH));
        await sleep(WAIT_BEFORE_NEXT_FETCH);
      }
    } else {
      break;
    }
  }

  return all_media;
};

/**
 * Download and save all media links from a wall to a text file
 * Saves IDs and URLs in the links folder for later use
 * @param {Object} params - Download parameters
 * @param {string} params.targetId - Facebook user/page/group ID
 * @param {boolean} params.includeVideo - Whether to include videos (default: true)
 * @param {number} params.pageLimit - Maximum pages to fetch (default: Infinity)
 * @param {boolean} params.isGetLargestPhoto - Whether to fetch HD photo URLs (default: false)
 * @returns {Promise<void>}
 */
export const downloadWallMediaLinks = async ({
  targetId,
  includeVideo = true,
  pageLimit = Infinity,
  isGetLargestPhoto = false,
}) => {
  log(t("gettingWallInfo").replace("{id}", targetId));

  const fileName = `${FOLDER_TO_SAVE_LINKS}/${targetId}.txt`;
  deleteFile(fileName); // delete if file exist

  await fetchWallMedia({
    targetId: targetId,
    pageLimit: pageLimit,
    pageFetchedCallback: (media) => {
      if (!includeVideo)
        media = media.filter((m) => m.type !== MEDIA_TYPE.VIDEO);

      if (isGetLargestPhoto) {
        // TODO get largest photo link
      }

      saveToFile(
        fileName,
        media.map((_) => _.id + ID_LINK_SEPERATOR + _.url).join("\n"),
        false
      );
    },
  });
};

/**
 * Download all media (photos and videos) from a user's wall/feed
 * Saves files organized in photos/ and videos/ subfolders
 * Supports HD photo fetching and duplicate detection
 * @param {Object} params - Download parameters
 * @param {string} params.targetId - Facebook user/page/group ID
 * @param {boolean} params.includeVideo - Whether to download videos (default: true)
 * @param {number} params.pageLimit - Maximum pages to fetch (default: Infinity)
 * @param {boolean} params.isGetLargestPhoto - Whether to fetch HD photo versions (default: false)
 * @returns {Promise<{saved: number, skipped: number, savedPhotos: number, savedVideos: number, skippedPhotos: number, skippedVideos: number}>} Download statistics
 */
export const downloadWallMedia = async ({
  targetId,
  includeVideo = true,
  pageLimit = Infinity,
  isGetLargestPhoto = false,
}) => {
  log(t("gettingWallInfo").replace("{id}", targetId));

  // Get or create user in database
  const userId = DATABASE_ENABLED ? getOrCreateUser(PLATFORM_FACEBOOK, targetId) : null;

  let savedPhotos = 0;
  let savedVideos = 0;
  let skippedPhotos = 0;
  let skippedVideos = 0;

  await fetchWallMedia({
    targetId: targetId,
    pageLimit: pageLimit,
    pageFetchedCallback: async (media) => {
      // save all media to directory
      for (let data of media) {
        let { id: media_id, url: media_url, type: media_type } = data;

        // Determine file path for this media
        const mediaSubfolder = media_type === MEDIA_TYPE.PHOTO ? 'photos' : 'videos';
        const dir = getSaveFolderPath(targetId, mediaSubfolder);
        const file_format = media_type === MEDIA_TYPE.PHOTO ? PHOTO_FILE_FORMAT : VIDEO_FILE_FORMAT;
        const savePath = `${dir}/${media_id}.${file_format}`;

        // Smart skip: check DB status for HD upgrade capability
        const skipCheck = checkMediaSkip(userId, media_id, isGetLargestPhoto && media_type === MEDIA_TYPE.PHOTO);

        if (skipCheck.skip) {
          if (media_type === MEDIA_TYPE.PHOTO) {
            log(`‚è≠Ô∏è  SKIPPING photo ${media_id} (${skipCheck.reason})`);
            skippedPhotos++;
          } else {
            log(`‚è≠Ô∏è  SKIPPING video ${media_id} (${skipCheck.reason})`);
            skippedVideos++;
          }
          continue;
        }

        if (skipCheck.needsUpgrade) {
          log(`üîÑ UPGRADE ${media_id} to HD (was SD)`);
        }

        // For photos, optionally fetch HD version
        let isHdDownload = false;
        if (isGetLargestPhoto && media_type == MEDIA_TYPE.PHOTO) {
          const hdResult = await attemptHDFetch(media_id, userId, skipCheck.needsUpgrade);

          if (hdResult.shouldSkip) {
            log(`‚è≠Ô∏è  SKIPPING ${media_id} (HD fetch failed, keeping SD version)`);
            skippedPhotos++;
            continue;
          }

          if (hdResult.url) {
            media_url = hdResult.url;
            isHdDownload = true;
          }
        }

        if (!includeVideo && media_type === MEDIA_TYPE.VIDEO) {
          log(t("skipVideo").replace("{url}", media_url));
          continue;
        }

        // Create directory if needed
        createIfNotExistDir(dir);
        const saved = media_type === MEDIA_TYPE.PHOTO ? savedPhotos : savedVideos;
        // Determine HD status for this save
        const mediaIsHd = media_type === MEDIA_TYPE.VIDEO ? true : isHdDownload;

        try {
          log(
            t("saving").replace("{count}", saved).replace("{path}", savePath)
          );
          await download(media_url, savePath);

          // Mark as downloaded in database with HD status
          saveMediaWithTracking(userId, media_id, mediaIsHd, savePath, skipCheck.needsUpgrade);

          if (media_type === MEDIA_TYPE.PHOTO) {
            savedPhotos++;
          } else {
            savedVideos++;
          }
        } catch (e) {
          log(
            S.BgRed + t("errorWhenSave").replace("{path}", savePath) + S.Reset,
            e.toString()
          );
        }
      }
    },
  });

  // Log summary
  logDownloadSummary({ savedPhotos, savedVideos, skippedPhotos, skippedVideos });

  return {
    saved: savedPhotos + savedVideos,
    skipped: skippedPhotos + skippedVideos,
    savedPhotos,
    savedVideos,
    skippedPhotos,
    skippedVideos
  };
};

/**
 * Batch download wall media from multiple users
 * Uses runBatchDownload for consistent progress reporting
 * @param {string[]} userIds - Array of Facebook user IDs
 * @param {Object} options - Download options (includeVideo, pageLimit, isGetLargestPhoto)
 * @returns {Promise<Array>} Array of results for each user
 */
export const downloadWallMediaBatch = async (userIds, options) => {
  return runBatchDownload(userIds, downloadWallMedia, options, {
    mediaType: 'wall media',
    showPhotoVideoSplit: true
  });
};

```

### scripts\lang.js
```js
/**
 * Language/Internationalization Module for FB Media Downloader
 *
 * Provides multi-language support for UI strings.
 * @module lang
 */

import { log } from "./logger.js";

/**
 * Available language keys
 * @constant {Object}
 * @property {string} vi - Vietnamese
 * @property {string} en - English
 */
export const LANGKEY = Object.freeze({
  vi: "vi",
  en: "en",
});

/** @type {string} Current language key */
let currentLangKey = LANGKEY.vi;

/**
 * Set the current application language
 * @param {string} langKey - Language key (use LANGKEY constants)
 * @returns {void}
 */
export const setLang = (langKey) => {
  if (langKey in LANGKEY) currentLangKey = langKey;
  else log("ERROR. Not found lang " + langKey);
};

/**
 * Get translated string for a key
 * Returns '?' if key not found in current language
 * @param {string} key - Translation key (e.g., 'pressAnyKey', 'albumInfo')
 * @returns {string} Translated string or '?' if not found
 */
export const t = (key) => {
  return langs[currentLangKey || LANGKEY.en][key] || "?";
};

export const langs = {
  vi: {
    albumInfo: "Xem th√¥ng tin album",
    findTimelinkAlbum: "T√¨m timeline album id c·ªßa page",
    downloadAlbum: "T·∫£i album (c·ªßa user/page/group)",
    downloadWall: "T·∫£i ·∫£nh/video tr√™n t∆∞·ªùng c·ªßa ƒë·ªëi t∆∞·ª£ng (user/group/page)",
    downloadUser: "[M·ªöI] T·∫£i to√†n b·ªô ·∫£nh/video c·ªßa user",
    downloadFromUrlFile: "[M·ªöI] T·∫£i t·ª´ file ch·ª©a link (instagram)",
    language: "Ng√¥n ng·ªØ / Language",
    help: "H·ªó tr·ª£",
    exit: "Tho√°t",
    pressAnyKey: "..Nh·∫•n ph√≠m b·∫•t k·ª≥ ƒë·ªÉ ti·∫øp t·ª•c..",
    chooseFunction: "> Ch·ªçn ch·ª©c nƒÉng: ",
    wrongChoice: "[!] Kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn l·∫°i.",
    back: "<- Quay l·∫°i",
    downAlbumTitle: "FB Media Downloader Tool > T·∫£i Album",
    downloadAllImageInAlbum: "T·∫£i t·∫•t c·∫£ ·∫¢NH trong album",
    downloadAllLinkInAlbum: "T·∫£i t·∫•t c·∫£ LINK c·ªßa ·∫£nh trong album",
    enterAlbumID: "> Nh·∫≠p album id (Nh·∫≠p -1 ƒë·ªÉ quay l·∫°i): ",
    enterStartPhotoID:
      "> T·∫£i t·ª´ v·ªã tr√≠ id ·∫£nh n√†o? (Nh·∫≠p 0 ƒë·ªÉ t·∫£i t·ª´ ƒë·∫ßu album): ",
    downloadHD: "> T·∫£i ·∫£nh ch·∫•t l∆∞·ª£ng cao nh·∫•t? (0-Kh√¥ng, 1-C√≥): ",
    saveHDLinkNotSupported: "[!] L∆∞u LINK ·∫£nh ch·∫•t l∆∞∆°ng cao hi·ªán ch∆∞a h·ªó tr·ª£.",
    downloadWallTitle: "FB Media Downloader Tool > T·∫£i ·∫£nh/video tr√™n t∆∞·ªùng",
    downloadAllMediaInWall:
      "T·∫£i t·∫•t c·∫£ ·∫¢NH/VIDEO tr√™n t∆∞·ªùng c·ªßa ƒë·ªëi t∆∞·ª£ng (user/gorup/page)",
    donwloadAllMediaLinkWall:
      "T·∫£i t·∫•t c·∫£ LINK ·∫£nh/video tr√™n t∆∞·ªùng c·ªßa ƒë·ªëi t∆∞·ª£ng (user/group/page)",
    enterTargetID:
      "> Nh·∫≠p id c·ªßa ƒë·ªëi t∆∞·ª£ng (user_id/group_id/page_id) (Nh·∫≠p -1 ƒë·ªÉ quay l·∫°i): ",
    howManyPageWall:
      "> T·∫£i bao nhi√™u trang (Nh·∫≠p 0 ƒë·ªÉ t·∫£i m·ªçi th·ª© tr√™n t∆∞·ªùng): ",
    downloadVideoWall: "> C√≥ t·∫£i c·∫£ video kh√¥ng (0-Kh√¥ng, 1-C√≥): ",
    downloadHDWall: "> T·∫£i ·∫£nh ch·∫•t l∆∞·ª£ng cao nh·∫•t? (0-Kh√¥ng, 1-C√≥): ",
    downloadUserTitle:
      "FB Media Downloader Tool > T·∫£i to√†n b·ªô ·∫£nh/video c·ªßa user",
    downloadUserImagePost: "T·∫£i to√†n b·ªô ·∫¢nh ƒë∆∞·ª£c ƒëƒÉng b·ªüi user",
    downloadUserVideoPost: "T·∫£i to√†n b·ªô Video ƒë∆∞·ª£c ƒëƒÉng b·ªüi user",
    enterUserID: "> Nh·∫≠p id c·ªßa user (Nh·∫≠p -1 ƒë·ªÉ quay l·∫°i): ",
    startPageUser:
      "> T·∫£i t·ª´ trang n√†o (Nh·∫≠p id trang. Nh·∫≠p 0 ƒë·ªÉ t·∫£i t·ª´ trang ƒë·∫ßu): ",
    howManyPageUser: "> T·∫£i bao nhi√™u trang (Nh·∫≠p 0 ƒë·ªÉ t·∫£i t·ªõi khi h·∫øt): ",
    enterFilePath: "> Nh·∫≠p ƒë∆∞·ªùng d·∫´n file (C√≥ th·ªÉ k√©o th·∫£ file v√†o ƒë√¢y): ",
    folderToSave: "> Nh·∫≠p t√™n folder ƒë·ªÉ l∆∞u: ",
    foundLinks: `T√¨m th·∫•y {length} links.`,
    downloadingLinks: `ƒêang t·∫£i {progress}`,
    errorWhenDownloadUrl: `[L·ªñI]: L·ªói khi t·∫£i. {url}.`,
    error: "[L·ªñI]: ",
    contact:
      "---- Li√™n h·ªá m√¨nh ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£: https://www.facebook.com/99.hoangtran/ ----",
    enterPageID: "> Nh·∫≠p page id (Nh·∫≠p -1 ƒë·ªÉ quay l·∫°i): ",
    foundTimelineAlbumID: "< T√åM TH·∫§Y Timeline Album ID: ",
    fetchingAlbumInfo: "< ƒêang t·∫£i th√¥ng tin album....",
    notFoundTimlineAlbum: "< KH√îNG T√åM TH·∫§Y timeline album.",
    downloadingPage: "ƒêANG T·∫¢I TRANG {page}...",
    foundWallMedia: `> T√åM TH·∫§Y {length} file ·∫£nh/video. (T·ªîNG: {total})`,
    pausing: `ƒêANG T·∫†M D·ª™NG {ms}ms...`,
    gettingWallInfo: `ƒêANG T·∫¢I D·ªÆ LI·ªÜU TR√äN T∆Ø·ªúNG C·ª¶A {id}...`,
    fetchingHDPhoto: "ƒêang t√¨m ·∫£nh c√≥ ƒë·ªô ph√¢n gi·∫£i l·ªõn nh·∫•t c·ªßa {media_id}...",
    skipVideo: `B·ªè qua video: {url}`,
    saving: `ƒêang l∆∞u {count}: {path}...`,
    errorWhenSave: `[!] L·ªñI khi t·∫£i {path}`,
    foundVideos: `> T√åM TH·∫§Y {length} videos. (T·ªîNG: {total})`,
    currentPageID: " > ID trang hi·ªán t·∫°i: ",
    nextPageID: " > ID trang sau: ",
    downloadingUserVideo: `ƒêANG T·∫¢I VIDEOS C·ª¶A USER {user_id}...`,
    savingUserMedia: `ƒêang l∆∞u {count}: {path}... {moreInfo}`,
    downloadingUserImage: `ƒêANG T·∫¢I ·∫¢NH C·ª¶A USER {user_id}...`,
    pageDontHaveTimelineAlbum: "! Page facebook n√†y kh√¥ng c√≥ timeline album.",
    downloadingAlbum: `ƒêANG T·∫¢I TRANG: {page}, K√≠ch th∆∞·ªõc trang: 100 ·∫£nh...`,
    foundAlbumMedia: `> T√åM TH·∫§Y {length} ·∫¢NH. (T·ªîNG: {total})`,
    fromPhotoID: "v·ªã tr√≠ photo_id=",
    fromBeginAlbum: "ƒë·∫ßu album",
    downloadAlbumFrom: `ƒêANG T·∫¢I D·ªÆ LI·ªÜU ALBUM {albumId} T·ª™ `,
    // Profile fetch menu
    fetchUserProfiles: "T·∫£i/C·∫≠p nh·∫≠t th√¥ng tin ng∆∞·ªùi d√πng",
    fetchProfilesTitle: "FB Media Downloader Tool > T·∫£i th√¥ng tin ng∆∞·ªùi d√πng",
    enterUIDsToFetch: "> Nh·∫≠p UID(s) c·∫ßn t·∫£i (ph√¢n c√°ch b·∫±ng d·∫•u ph·∫©y): ",
    includeLikes: "> C√≥ t·∫£i danh s√°ch trang ƒë√£ th√≠ch kh√¥ng? (0-Kh√¥ng, 1-C√≥): ",
    profileFetched: "ƒê√£ t·∫£i th√¥ng tin",
    profileUpdated: "ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin",
    profileNoChanges: "Kh√¥ng c√≥ thay ƒë·ªïi",
    profileFailed: "T·∫£i th·∫•t b·∫°i",
    fieldsChanged: "Tr∆∞·ªùng thay ƒë·ªïi",
  },
  en: {
    albumInfo: "Get album info",
    findTimelinkAlbum: "Find timeline album id of page",
    downloadAlbum: "Download album (user/page/group)",
    downloadWall: "Download wall media (user/group/page)",
    downloadUser: "[NEW] Download all media (video/photo) of user",
    downloadFromUrlFile: "[NEW] Download media from urls file (instagram)",
    language: "Ng√¥n ng·ªØ / Language",
    help: "Help",
    exit: "Exit",
    pressAnyKey: "..Press any key to continue..",
    chooseFunction: "> Your choice: ",
    wrongChoice: "[!] Not valid. Please choose again.",
    back: "<- Go back",
    downAlbumTitle: "FB Media Downloader Tool > Download Album",
    downloadAllImageInAlbum: "Download all images FILE in album",
    downloadAllLinkInAlbum: "Download all images LINK in album",
    enterAlbumID: "> Enter album id (Enter -1 to go back): ",
    enterStartPhotoID:
      "> Start download from which image's ID? (Enter 0 to download all album): ",
    downloadHD: "> Download highest resolution image? (0-No, 1-Yes): ",
    saveHDLinkNotSupported:
      "[!] Save image's LINK with highest resolution is not supported yet.",
    downloadWallTitle:
      "FB Media Downloader Tool > Download wall media (images/video)",
    downloadAllMediaInWall:
      "Download all media FILE on target wall (user/gorup/page)",
    donwloadAllMediaLinkWall:
      "Download all media LINK on target wall (user/group/page)",
    enterTargetID:
      "> Enter target ID (user_id/group_id/page_id) (Enter -1 to go back): ",
    howManyPageWall:
      "> How many page you want to download? (Enter 0 to download all): ",
    downloadVideoWall: "> Download video? (0-No, 1-Yes): ",
    downloadHDWall: "> Download largest photo? (0-No, 1-Yes): ",
    downloadUserTitle:
      "FB Media Downloader Tool > Download all media from user",
    downloadUserImagePost: "Download all Image posted by user",
    downloadUserVideoPost: "Download all Video posted by user",
    enterUserID: "> Enter user id (Enter -1 to go back): ",
    startPageUser:
      "> Download from page id? (Enter 0 to download from the first page): ",
    howManyPageUser:
      "> How many page? (Enter 0 to download to the last page): ",
    enterFilePath:
      "> Enter absolute file path (Or drag and drop file in here): ",
    folderToSave: "> Enter folder's name to save: ",
    foundLinks: `Found {length} links.`,
    downloadingLinks: `ƒêang t·∫£i {progress}`,
    errorWhenDownloadUrl: `[ERROR]: Error when download. {url}.`,
    error: "[ERROR]: ",
    contact:
      "---- Contact me to get help: https://www.facebook.com/99.hoangtran/ ----",
    enterPageID: "> Enter page id (Enter -1 to go back): ",
    foundTsavingUserVideo: `ƒêang l∆∞u {count}: {path}... {moreInfo}`,
    imelineAlbumID: "< FOUND Timeline Album ID: ",
    fetchingAlbumInfo: "< Fetching album info....",
    notFoundTimlineAlbum: "< NOT FOUND timeline album.",
    downloadingPage: "Downloading page number {page}...",
    foundWallMedia: `> FOUND {length} media files. (TOTAL: {total})`,
    pausing: `PAUSE for {ms}ms...`,
    gettingWallInfo: `FETCHING DATA FROM WALL OF {id}...`,
    fetchingHDPhoto: "Fetching highest resolution of {media_id}...",
    skipVideo: `Skip video: {url}`,
    saving: `Saving {count}: {path}...`,
    errorWhenSave: `[!] L·ªñI khi t·∫£i {path}`,
    foundVideos: `> FOUND {length} videos. (TOTAL: {total})`,
    currentPageID: " > Current page id: ",
    nextPageID: " > Next page id: ",
    downloadingUserVideo: `DOWNLOADING VIDEOS OF USER {user_id}...`,
    savingUserMedia: `Saving {count}: {path}... {moreInfo}`,
    downloadingUserImage: `DOWNLOADING PHOTOS OF USER {user_id}...`,
    pageDontHaveTimelineAlbum: "! This fb page dont have timeline album.",
    downloadingAlbum: `DOWNLOADING PAGE: {page}, Page size: 100 photos...`,
    foundAlbumMedia: `> FOUND {length} PHOTOS. (TOTAL: {total})`,
    fromPhotoID: "photo_id=",
    fromBeginAlbum: "begin of album",
    downloadAlbumFrom: `DOWNLOADING ALBUM {albumId} FROM `,
    // Profile fetch menu
    fetchUserProfiles: "Fetch/Update User Profiles",
    fetchProfilesTitle: "FB Media Downloader Tool > Fetch User Profiles",
    enterUIDsToFetch: "> Enter UID(s) to fetch (comma-separated): ",
    includeLikes: "> Include page likes? (0-No, 1-Yes): ",
    profileFetched: "Profile fetched",
    profileUpdated: "Profile updated",
    profileNoChanges: "No changes",
    profileFailed: "Fetch failed",
    fieldsChanged: "Fields changed",
  },
};

```

### scripts\logger.js
```js
/**
 * Logger Module for FB Media Downloader
 *
 * Provides centralized logging functionality.
 * Can be extended for file logging or log levels.
 * @module logger
 */

/**
 * Log messages to console
 * Wrapper around console.log for centralized logging control
 * @param {...any} params - Values to log (same as console.log)
 * @returns {void}
 */
export const log = (...params) => {
  console.log(...params);
};

```

### scripts\menu.js
```js
/**
 * Menu Module (Legacy Entry Point)
 *
 * This file is maintained for backward compatibility.
 * All functionality has been moved to the menu/ subdirectory.
 * 
 * New code should import from './menu/index.js' directly.
 * @module menu
 * @deprecated Use './menu/index.js' instead
 */

// Re-export everything from the new modular structure
export * from './menu/index.js';

```

### scripts\proxy_manager.js
```js
/**
 * Proxy Manager for FB Media Downloader
 * Supports single proxy, proxy list file, and automatic rotation
 * 
 * Configuration via .env:
 * - PROXY_ENABLED=true/false
 * - PROXY_URL=http://ip:port (single proxy)
 * - PROXY_LIST_FILE=proxies.txt (file with list of proxies, one per line)
 * 
 * Proxy URL formats supported:
 * - http://ip:port
 * - http://user:pass@ip:port
 * - https://ip:port
 * - socks4://ip:port
 * - socks5://ip:port
 * - socks5://user:pass@ip:port
 */

import fs from 'fs';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { SocksProxyAgent } from 'socks-proxy-agent';
import { log } from './logger.js';

// Proxy state
let proxyList = [];
let currentProxyIndex = 0;
let proxyEnabled = false;
let failedProxies = new Set();

/**
 * Initialize proxy configuration from environment variables
 */
export const initProxy = () => {
    proxyEnabled = process.env.PROXY_ENABLED === 'true';

    if (!proxyEnabled) {
        log('üîå Proxy: Disabled');
        return;
    }

    // Check for proxy list file first
    const proxyListFile = process.env.PROXY_LIST_FILE;
    if (proxyListFile && fs.existsSync(proxyListFile)) {
        loadProxyListFromFile(proxyListFile);
    } else if (process.env.PROXY_URL) {
        // Single proxy from PROXY_URL
        proxyList = [process.env.PROXY_URL.trim()];
        log(`üîå Proxy: Using single proxy`);
    } else {
        log('‚ö†Ô∏è Proxy: Enabled but no PROXY_URL or PROXY_LIST_FILE configured');
        proxyEnabled = false;
        return;
    }

    if (proxyList.length > 0) {
        log(`üîå Proxy: Loaded ${proxyList.length} proxy(ies)`);
    }
};

/**
 * Load proxies from a text file (one proxy per line)
 * Format: ip:port or full URL like http://ip:port
 * @param {string} filePath - Path to proxy list file
 */
export const loadProxyListFromFile = (filePath) => {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const lines = content.split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('#')); // Skip empty lines and comments

        proxyList = lines.map(line => {
            // If it's just ip:port, assume HTTP
            if (!line.includes('://')) {
                return `http://${line}`;
            }
            return line;
        });

        log(`üìã Loaded ${proxyList.length} proxies from ${filePath}`);
    } catch (error) {
        log(`‚ö†Ô∏è Error loading proxy list: ${error.message}`);
        proxyList = [];
    }
};

/**
 * Get the current proxy URL
 * @returns {string|null} Current proxy URL or null if disabled
 */
export const getCurrentProxy = () => {
    if (!proxyEnabled || proxyList.length === 0) {
        return null;
    }
    return proxyList[currentProxyIndex];
};

/**
 * Create a proxy agent for the given URL
 * @param {string} proxyUrl - Proxy URL
 * @returns {object|null} Proxy agent or null
 */
export const createProxyAgent = (proxyUrl) => {
    if (!proxyUrl) return null;

    try {
        if (proxyUrl.startsWith('socks4://') || proxyUrl.startsWith('socks5://')) {
            return new SocksProxyAgent(proxyUrl);
        } else {
            // HTTP/HTTPS proxy
            return new HttpsProxyAgent(proxyUrl);
        }
    } catch (error) {
        log(`‚ö†Ô∏è Error creating proxy agent: ${error.message}`);
        return null;
    }
};

/**
 * Get proxy agent for current proxy
 * @returns {object|null} Proxy agent or null if disabled
 */
export const getProxyAgent = () => {
    const proxyUrl = getCurrentProxy();
    return createProxyAgent(proxyUrl);
};

/**
 * Rotate to the next proxy in the list
 * @param {boolean} markFailed - Whether to mark current proxy as failed
 * @returns {string|null} New proxy URL or null if no more proxies
 */
export const rotateProxy = (markFailed = false) => {
    if (!proxyEnabled || proxyList.length === 0) {
        return null;
    }

    if (markFailed) {
        const failedProxy = proxyList[currentProxyIndex];
        failedProxies.add(failedProxy);
        log(`‚ùå Marking proxy as failed: ${maskProxyUrl(failedProxy)}`);
    }

    // Find next working proxy
    let attempts = 0;
    do {
        currentProxyIndex = (currentProxyIndex + 1) % proxyList.length;
        attempts++;
    } while (
        failedProxies.has(proxyList[currentProxyIndex]) &&
        attempts < proxyList.length
    );

    // If all proxies failed, reset and try again
    if (attempts >= proxyList.length) {
        log('‚ö†Ô∏è All proxies failed. Resetting failed list...');
        failedProxies.clear();
        currentProxyIndex = 0;
    }

    const newProxy = proxyList[currentProxyIndex];
    log(`üîÑ Switched to proxy: ${maskProxyUrl(newProxy)}`);
    return newProxy;
};

/**
 * Mask proxy URL for logging (hide password)
 * @param {string} proxyUrl - Proxy URL
 * @returns {string} Masked URL
 */
export const maskProxyUrl = (proxyUrl) => {
    try {
        const url = new URL(proxyUrl);
        if (url.password) {
            url.password = '***';
        }
        return url.toString();
    } catch {
        return proxyUrl;
    }
};

/**
 * Get proxy statistics
 * @returns {object} Proxy stats
 */
export const getProxyStats = () => {
    return {
        enabled: proxyEnabled,
        total: proxyList.length,
        currentIndex: currentProxyIndex,
        failed: failedProxies.size,
        current: proxyEnabled ? maskProxyUrl(getCurrentProxy()) : null
    };
};

/**
 * Check if proxy is enabled
 * @returns {boolean}
 */
export const isProxyEnabled = () => proxyEnabled;

/**
 * Toggle proxy on/off
 * @returns {boolean} New proxy state
 */
export const toggleProxy = () => {
    proxyEnabled = !proxyEnabled;
    log(`üîå Proxy: ${proxyEnabled ? 'ENABLED' : 'DISABLED'}`);
    return proxyEnabled;
};

/**
 * Set proxy enabled state
 * @param {boolean} enabled - Whether to enable proxy
 */
export const setProxyEnabled = (enabled) => {
    proxyEnabled = enabled;
    log(`üîå Proxy: ${proxyEnabled ? 'ENABLED' : 'DISABLED'}`);
};

/**
 * Test current proxy connectivity
 * @returns {Promise<object>} Test result with success status and IP
 */
export const testProxyConnection = async () => {
    const agent = getProxyAgent();

    if (!agent) {
        log('‚ÑπÔ∏è No proxy configured, testing direct connection...');
    }

    try {
        const response = await fetch('https://api.ipify.org?format=json', {
            agent,
            timeout: 10000
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        const result = {
            success: true,
            ip: data.ip,
            proxy: agent ? maskProxyUrl(getCurrentProxy()) : 'direct'
        };

        log(`‚úÖ Connection test passed! IP: ${data.ip}`);
        return result;
    } catch (error) {
        const result = {
            success: false,
            error: error.message,
            proxy: agent ? maskProxyUrl(getCurrentProxy()) : 'direct'
        };

        log(`‚ùå Connection test failed: ${error.message}`);
        return result;
    }
};

/**
 * Test a single proxy and return detailed results
 * @param {string} proxyUrl - Proxy URL to test
 * @param {number} timeout - Timeout in ms (default 10000)
 * @returns {Promise<object>} Test result with success, latency, IP
 */
export const testSingleProxy = async (proxyUrl, timeout = 10000) => {
    const startTime = Date.now();

    try {
        const agent = createProxyAgent(proxyUrl);
        if (!agent) {
            return {
                proxy: proxyUrl,
                success: false,
                error: 'Failed to create proxy agent',
                latency: null,
                ip: null
            };
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        const response = await fetch('https://api.ipify.org?format=json', {
            agent,
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        const latency = Date.now() - startTime;

        return {
            proxy: proxyUrl,
            success: true,
            latency,
            ip: data.ip,
            error: null
        };
    } catch (error) {
        return {
            proxy: proxyUrl,
            success: false,
            latency: null,
            ip: null,
            error: error.name === 'AbortError' ? 'Timeout' : error.message
        };
    }
};

/**
 * Check health of all proxies in the list
 * Tests all proxies in parallel and returns detailed results
 * @param {object} options - Options
 * @param {number} options.timeout - Timeout per proxy in ms (default 10000)
 * @param {boolean} options.removeDeadProxies - Remove dead proxies from list (default false)
 * @param {function} options.onProgress - Progress callback (current, total, result)
 * @returns {Promise<object>} Health check results
 */
export const checkAllProxies = async (options = {}) => {
    const { timeout = 10000, removeDeadProxies = false, onProgress } = options;

    if (!proxyEnabled || proxyList.length === 0) {
        log('‚ö†Ô∏è No proxies loaded to check');
        return {
            total: 0,
            healthy: 0,
            dead: 0,
            results: []
        };
    }

    log(`\nüîç Testing ${proxyList.length} proxies (timeout: ${timeout / 1000}s each)...\n`);

    const results = [];
    let completed = 0;

    // Test all proxies in parallel with concurrency limit
    const concurrencyLimit = 10; // Test 10 proxies at a time
    const chunks = [];

    for (let i = 0; i < proxyList.length; i += concurrencyLimit) {
        chunks.push(proxyList.slice(i, i + concurrencyLimit));
    }

    for (const chunk of chunks) {
        const chunkResults = await Promise.all(
            chunk.map(async (proxyUrl) => {
                const result = await testSingleProxy(proxyUrl, timeout);
                completed++;

                if (onProgress) {
                    onProgress(completed, proxyList.length, result);
                }

                return result;
            })
        );
        results.push(...chunkResults);
    }

    // Sort by latency (healthy first, then by speed)
    results.sort((a, b) => {
        if (a.success && !b.success) return -1;
        if (!a.success && b.success) return 1;
        if (a.success && b.success) return a.latency - b.latency;
        return 0;
    });

    const healthy = results.filter(r => r.success);
    const dead = results.filter(r => !r.success);

    // Display results
    log('\n' + '='.repeat(70));
    log('üìä PROXY HEALTH CHECK RESULTS');
    log('='.repeat(70));

    log('\n‚úÖ HEALTHY PROXIES:');
    if (healthy.length === 0) {
        log('   (none)');
    } else {
        healthy.forEach((r, i) => {
            log(`   ${i + 1}. ${maskProxyUrl(r.proxy)}`);
            log(`      IP: ${r.ip} | Latency: ${r.latency}ms`);
        });
    }

    log('\n‚ùå DEAD PROXIES:');
    if (dead.length === 0) {
        log('   (none)');
    } else {
        dead.forEach((r, i) => {
            log(`   ${i + 1}. ${maskProxyUrl(r.proxy)}`);
            log(`      Error: ${r.error}`);
        });
    }

    log('\n' + '-'.repeat(70));
    log(`üìà Summary: ${healthy.length} healthy, ${dead.length} dead out of ${proxyList.length} total`);

    if (healthy.length > 0) {
        const avgLatency = Math.round(healthy.reduce((sum, r) => sum + r.latency, 0) / healthy.length);
        const fastestProxy = healthy[0];
        log(`‚ö° Average latency: ${avgLatency}ms | Fastest: ${fastestProxy.latency}ms`);
    }

    // Remove dead proxies if requested
    if (removeDeadProxies && dead.length > 0) {
        const deadUrls = new Set(dead.map(r => r.proxy));
        const originalCount = proxyList.length;
        proxyList = proxyList.filter(p => !deadUrls.has(p));
        currentProxyIndex = 0; // Reset to first proxy
        failedProxies.clear(); // Clear failed list

        log(`\nüßπ Removed ${originalCount - proxyList.length} dead proxies. ${proxyList.length} remaining.`);
    }

    log('='.repeat(70) + '\n');

    return {
        total: results.length,
        healthy: healthy.length,
        dead: dead.length,
        averageLatency: healthy.length > 0
            ? Math.round(healthy.reduce((sum, r) => sum + r.latency, 0) / healthy.length)
            : null,
        fastestProxy: healthy.length > 0 ? healthy[0] : null,
        results
    };
};

/**
 * Get list of healthy proxies only
 * @returns {string[]} Array of healthy proxy URLs
 */
export const getHealthyProxies = () => {
    return proxyList.filter(p => !failedProxies.has(p));
};

/**
 * Reorder proxies by latency (fastest first)
 * @param {object[]} healthResults - Results from checkAllProxies
 */
export const reorderByLatency = (healthResults) => {
    if (!healthResults?.results) return;

    const healthyByLatency = healthResults.results
        .filter(r => r.success)
        .sort((a, b) => a.latency - b.latency)
        .map(r => r.proxy);

    if (healthyByLatency.length > 0) {
        proxyList = healthyByLatency;
        currentProxyIndex = 0;
        failedProxies.clear();
        log(`üîÑ Reordered ${proxyList.length} proxies by latency (fastest first)`);
    }
};

// Initialize on module load
initProxy();

```

### scripts\rate_limit_manager.js
```js
/**
 * Rate Limit Manager for Facebook Graph API
 * Automatically handles rate limiting based on X-App-Usage header
 * 
 * Facebook's X-App-Usage header format:
 * { "call_count": 28, "total_cputime": 15, "total_time": 24 }
 * Values are percentages (0-100) of the rolling 1-hour limit
 */

import { WAIT_BEFORE_NEXT_FETCH } from '../config.js';
import { log } from './logger.js';

// Rate limit state
let currentUsage = {
    call_count: 0,
    total_cputime: 0,
    total_time: 0,
    lastUpdated: null
};

// Configuration thresholds
const THRESHOLDS = {
    // Below this: no delay needed
    LOW: 20,
    // Between LOW and MEDIUM: use minimum delay
    MEDIUM: 50,
    // Between MEDIUM and HIGH: use moderate delay
    HIGH: 80,
    // Above HIGH: use maximum delay (approaching rate limit)
    CRITICAL: 95
};

// Delay values in milliseconds
const DELAYS = {
    NONE: 0,
    MINIMUM: WAIT_BEFORE_NEXT_FETCH || 500,
    MODERATE: 2000,
    HIGH: 5000,
    CRITICAL: 15000,
    RATE_LIMITED: 60000  // When 429 received
};

/**
 * Parse the X-App-Usage header from Facebook API response
 * @param {Response} response - Fetch response object
 * @returns {object|null} Parsed usage data or null
 */
export const parseRateLimitHeader = (response) => {
    try {
        const usageHeader = response.headers.get('x-app-usage');
        if (usageHeader) {
            const usage = JSON.parse(usageHeader);
            return {
                call_count: usage.call_count || 0,
                total_cputime: usage.total_cputime || 0,
                total_time: usage.total_time || 0
            };
        }
    } catch (e) {
        // Silently ignore parsing errors
    }
    return null;
};

/**
 * Update the current rate limit usage state
 * @param {object} usage - New usage data from header
 */
export const updateRateLimitUsage = (usage) => {
    if (usage) {
        currentUsage = {
            ...usage,
            lastUpdated: Date.now()
        };
    }
};

/**
 * Get the current rate limit usage
 * @returns {object} Current usage state
 */
export const getRateLimitUsage = () => ({ ...currentUsage });

/**
 * Get the highest usage percentage among all metrics
 * @returns {number} Maximum usage percentage (0-100)
 */
export const getMaxUsagePercent = () => {
    return Math.max(
        currentUsage.call_count,
        currentUsage.total_cputime,
        currentUsage.total_time
    );
};

/**
 * Calculate the recommended delay based on current rate limit usage
 * @param {boolean} verbose - Whether to log delay decisions
 * @returns {number} Recommended delay in milliseconds
 */
export const calculateSmartDelay = (verbose = false) => {
    const maxUsage = getMaxUsagePercent();
    let delay;
    let reason;

    if (maxUsage >= THRESHOLDS.CRITICAL) {
        delay = DELAYS.CRITICAL;
        reason = `‚ö†Ô∏è CRITICAL usage (${maxUsage}%)`;
    } else if (maxUsage >= THRESHOLDS.HIGH) {
        delay = DELAYS.HIGH;
        reason = `üî∂ High usage (${maxUsage}%)`;
    } else if (maxUsage >= THRESHOLDS.MEDIUM) {
        delay = DELAYS.MODERATE;
        reason = `üìä Moderate usage (${maxUsage}%)`;
    } else if (maxUsage >= THRESHOLDS.LOW) {
        delay = DELAYS.MINIMUM;
        reason = `‚úÖ Normal usage (${maxUsage}%)`;
    } else {
        delay = DELAYS.NONE;
        reason = `üöÄ Low usage (${maxUsage}%)`;
    }

    if (verbose && delay > 0) {
        log(`${reason} - waiting ${delay}ms`);
    }

    return delay;
};

/**
 * Smart sleep based on current rate limit usage
 * Replaces the fixed WAIT_BEFORE_NEXT_FETCH approach
 * @param {boolean} verbose - Whether to log delay decisions
 * @returns {Promise<void>}
 */
export const smartSleep = async (verbose = true) => {
    const delay = calculateSmartDelay(verbose);
    if (delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
    }
};

/**
 * Handle 429 Too Many Requests response
 * Parses Retry-After header if available
 * @param {Response} response - Fetch response object
 * @returns {number} Recommended wait time in milliseconds
 */
export const handle429Response = (response) => {
    // Try to get Retry-After header (in seconds)
    const retryAfter = response.headers.get('retry-after');
    if (retryAfter) {
        const seconds = parseInt(retryAfter, 10);
        if (!isNaN(seconds)) {
            return seconds * 1000;
        }
    }

    // Try business use case header for estimated time
    try {
        const businessHeader = response.headers.get('x-business-use-case-usage');
        if (businessHeader) {
            const data = JSON.parse(businessHeader);
            // Find estimated_time_to_regain_access in any account
            for (const accountId of Object.keys(data)) {
                const accountData = data[accountId];
                if (Array.isArray(accountData)) {
                    for (const item of accountData) {
                        if (item.estimated_time_to_regain_access) {
                            return item.estimated_time_to_regain_access * 60 * 1000; // Convert minutes to ms
                        }
                    }
                }
            }
        }
    } catch (e) {
        // Ignore parsing errors
    }

    // Default wait time for 429
    return DELAYS.RATE_LIMITED;
};

/**
 * Format rate limit status for display
 * @returns {string} Formatted status string
 */
export const formatRateLimitStatus = () => {
    const { call_count, total_cputime, total_time, lastUpdated } = currentUsage;
    const maxUsage = getMaxUsagePercent();

    let statusIcon = 'üü¢';
    if (maxUsage >= THRESHOLDS.CRITICAL) statusIcon = 'üî¥';
    else if (maxUsage >= THRESHOLDS.HIGH) statusIcon = 'üü†';
    else if (maxUsage >= THRESHOLDS.MEDIUM) statusIcon = 'üü°';

    const lastUpdateStr = lastUpdated
        ? `${Math.round((Date.now() - lastUpdated) / 1000)}s ago`
        : 'never';

    return `${statusIcon} Rate Limit: calls=${call_count}% cpu=${total_cputime}% time=${total_time}% (updated ${lastUpdateStr})`;
};

/**
 * Check if we should proceed with API call or wait
 * @returns {{ canProceed: boolean, waitTime: number }}
 */
export const checkRateLimit = () => {
    const maxUsage = getMaxUsagePercent();

    if (maxUsage >= THRESHOLDS.CRITICAL) {
        return {
            canProceed: false,
            waitTime: DELAYS.CRITICAL,
            message: `Rate limit critical (${maxUsage}%), waiting...`
        };
    }

    return {
        canProceed: true,
        waitTime: calculateSmartDelay(false),
        message: null
    };
};

```

### scripts\shared_readline.js
```js
// Shared readline interface for the entire application
// This prevents conflicts between token_validator and menu readline instances
import readline from 'readline';

let rl = null;

/**
 * Get or create the shared readline interface
 * @returns {readline.Interface}
 */
export const getSharedReadline = () => {
    if (!rl) {
        rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });

        // Exit on close
        rl.on('close', () => process.exit(0));
    }
    return rl;
};

/**
 * Create a prompt function using the shared readline
 * @param {string} query - Prompt text
 * @param {string} color - Color code (optional)
 * @returns {Promise<string>}
 */
export const createPrompt = (color = '') => {
    return (query) => new Promise((resolve) => {
        getSharedReadline().question(color + query + '\x1b[0m', resolve);
    });
};

/**
 * Close the shared readline (should only be called on app exit)
 */
export const closeSharedReadline = () => {
    if (rl) {
        rl.close();
        rl = null;
    }
};

```

### scripts\sql_playground.js
```js
/**
 * SQL Playground - Interactive SQL query tool
 * 
 * Run custom SQL queries against the downloader database.
 * 
 * Usage: node scripts/sql_playground.js
 */

import Database from 'better-sqlite3';
import readline from 'readline';
import { DATABASE_PATH, DATABASE_ENABLED } from '../config.js';

if (!DATABASE_ENABLED) {
    console.log('Database is disabled. Enable it in config to use SQL playground.');
    process.exit(1);
}

const db = new Database(DATABASE_PATH, { readonly: false });
db.pragma('journal_mode = WAL');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// ANSI colors
const C = {
    reset: '\x1b[0m',
    cyan: '\x1b[36m',
    yellow: '\x1b[33m',
    green: '\x1b[32m',
    red: '\x1b[31m',
    dim: '\x1b[2m',
    bold: '\x1b[1m',
};

console.log(`
${C.cyan}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${C.reset}
${C.cyan}‚ïë${C.reset}  ${C.bold}SQL Playground${C.reset} - Interactive Database Query Tool          ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£${C.reset}
${C.cyan}‚ïë${C.reset}  Database: ${C.dim}${DATABASE_PATH}${C.reset}
${C.cyan}‚ïë${C.reset}  Commands:                                                    ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.tables${C.reset}     - List all tables                         ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.schema <t>${C.reset}  - Show table schema                       ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.views${C.reset}      - List all views                          ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.stats${C.reset}      - Show database statistics                ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.clear${C.reset}      - Clear screen                            ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}    ${C.yellow}.exit${C.reset}       - Exit playground                         ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}                                                              ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïë${C.reset}  ${C.dim}End queries with ; for SELECT or just press Enter for DDL${C.reset}  ${C.cyan}‚ïë${C.reset}
${C.cyan}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${C.reset}
`);

// =============================================================
// [ADDED] Expanded (vertical) mode state
// =============================================================
let expandedMode = false;

let queryBuffer = '';

function prompt() {
    const prefix = queryBuffer ? '...> ' : 'sql> ';
    rl.question(`${C.green}${prefix}${C.reset}`, handleInput);
}

function formatTable(rows) {
    if (!rows || rows.length === 0) {
        console.log(`${C.dim}(no results)${C.reset}`);
        return;
    }

    const columns = Object.keys(rows[0]);
    const widths = {};

    // Calculate column widths
    columns.forEach(col => {
        widths[col] = Math.max(
            col.length,
            ...rows.map(row => String(row[col] ?? 'NULL').substring(0, 50).length)
        );
    });

    // Header
    const header = columns.map(col => col.padEnd(widths[col])).join(' ‚îÇ ');
    const separator = columns.map(col => '‚îÄ'.repeat(widths[col])).join('‚îÄ‚îº‚îÄ');

    console.log(`${C.cyan}${header}${C.reset}`);
    console.log(`${C.dim}${separator}${C.reset}`);

    // Rows
    rows.forEach(row => {
        const line = columns.map(col => {
            let val = row[col];
            if (val === null) val = 'NULL';
            return String(val).substring(0, 50).padEnd(widths[col]);
        }).join(' ‚îÇ ');
        console.log(line);
    });

    console.log(`${C.dim}(${rows.length} row${rows.length !== 1 ? 's' : ''})${C.reset}\n`);
}

// =============================================================
// [ADDED] Expanded / vertical formatter (psql \x style)
// =============================================================
function formatExpanded(rows) {
    if (!rows || rows.length === 0) {
        console.log(`${C.dim}(no results)${C.reset}`);
        return;
    }

    rows.forEach((row, index) => {
        console.log(
            `${C.cyan}-[ RECORD ${index + 1} ]${'‚îÄ'.repeat(40)}${C.reset}`
        );
        Object.entries(row).forEach(([key, value]) => {
            const val = value === null ? 'NULL' : String(value);
            console.log(
                `${C.yellow}${key.padEnd(24)}${C.reset} | ${val}`
            );
        });
        console.log();
    });

    console.log(
        `${C.dim}(${rows.length} row${rows.length !== 1 ? 's' : ''})${C.reset}\n`
    );
}

// =============================================================
// [MODIFIED] SELECT ‚Üí switch formatter, DDL gi·ªØ nguy√™n
// =============================================================
function executeQuery(sql) {
    const trimmed = sql.trim();
    if (!trimmed) return;

    try {
        const isSelect = /^\s*(SELECT|PRAGMA|EXPLAIN)/i.test(trimmed);

        if (isSelect) {
            const rows = db.prepare(trimmed).all();
            expandedMode ? formatExpanded(rows) : formatTable(rows);
        } else {
            db.exec(trimmed);
            console.log(`${C.green}‚úì Query executed successfully${C.reset}\n`);
        }
    } catch (error) {
        console.log(`${C.red}Error: ${error.message}${C.reset}\n`);
    }
}

// =============================================================
// [MODIFIED] handleCommand ‚Äì KH√îNG XO√Å case n√†o
// =============================================================
function handleCommand(cmd) {
    const parts = cmd.trim().split(/\s+/);
    const command = parts[0].toLowerCase();
    const arg = parts.slice(1).join(' ');

    switch (command) {

        // [ADDED]
        case '.x':
            expandedMode = !expandedMode;
            console.log(
                `${C.green}Expanded mode: ${expandedMode ? 'ON' : 'OFF'}${C.reset}\n`
            );
            break;

        // [UNCHANGED]
        case '.tables':
            const tables = db.prepare(`
                SELECT name FROM sqlite_master
                WHERE type='table' AND name NOT LIKE 'sqlite_%'
                ORDER BY name
            `).all();
            console.log(`\n${C.bold}Tables:${C.reset}`);
            tables.forEach(t => console.log(`  ${C.yellow}${t.name}${C.reset}`));
            console.log();
            break;

        // [UNCHANGED]
        case '.views':
            const views = db.prepare(`
                SELECT name FROM sqlite_master
                WHERE type='view'
                ORDER BY name
            `).all();
            console.log(`\n${C.bold}Views:${C.reset}`);
            views.forEach(v => console.log(`  ${C.yellow}${v.name}${C.reset}`));
            console.log();
            break;

        // [UNCHANGED]
        case '.schema':
            if (!arg) {
                console.log(`${C.red}Usage: .schema <table_name>${C.reset}\n`);
                break;
            }
            const schema = db.prepare(`
                SELECT sql FROM sqlite_master
                WHERE name = ? AND sql IS NOT NULL
            `).get(arg);
            if (schema) {
                console.log(`\n${C.dim}${schema.sql}${C.reset}\n`);
            } else {
                console.log(`${C.red}Table '${arg}' not found${C.reset}\n`);
            }
            break;

        // [UNCHANGED ‚Äì FULLY RESTORED]
        case '.stats':
            console.log(`\n${C.bold}Database Statistics:${C.reset}`);
            const stats = [
                ['users', 'SELECT COUNT(*) as count FROM users'],
                ['user_profiles', 'SELECT COUNT(*) as count FROM user_profiles'],
                ['fb_pages', 'SELECT COUNT(*) as count FROM fb_pages'],
                ['user_page_likes', 'SELECT COUNT(*) as count FROM user_page_likes'],
                ['saved_media', 'SELECT COUNT(*) as count FROM saved_media'],
                ['username_history', 'SELECT COUNT(*) as count FROM username_history'],
            ];
            stats.forEach(([name, sql]) => {
                try {
                    const result = db.prepare(sql).get();
                    console.log(`  ${C.yellow}${name}:${C.reset} ${result.count} rows`);
                } catch {
                    console.log(`  ${C.yellow}${name}:${C.reset} ${C.dim}(not found)${C.reset}`);
                }
            });
            console.log();
            break;

        // [UNCHANGED]
        case '.clear':
            console.clear();
            break;

        // [UNCHANGED]
        case '.exit':
        case '.quit':
            console.log(`${C.dim}Goodbye!${C.reset}`);
            db.close();
            rl.close();
            process.exit(0);

        default:
            console.log(`${C.red}Unknown command: ${command}${C.reset}`);
            console.log(
                `${C.dim}Type .tables, .views, .schema <table>, .stats, .x, .clear, or .exit${C.reset}\n`
            );
    }
}

function handleInput(input) {
    const trimmed = input.trim();

    // Handle special commands
    if (trimmed.startsWith('.')) {
        handleCommand(trimmed);
        prompt();
        return;
    }

    // Build multi-line query
    queryBuffer += (queryBuffer ? ' ' : '') + input;

    // Execute if ends with semicolon or is a DDL statement
    if (queryBuffer.trim().endsWith(';') ||
        /^\s*(CREATE|DROP|ALTER|INSERT|UPDATE|DELETE)/i.test(queryBuffer)) {
        executeQuery(queryBuffer);
        queryBuffer = '';
    }

    prompt();
}

// Handle Ctrl+C
rl.on('close', () => {
    console.log(`\n${C.dim}Goodbye!${C.reset}`);
    db.close();
    process.exit(0);
});

// Start the REPL
prompt();

```

### scripts\sql_web.js
```js
/**
 * Web SQL Playground - Browser-based SQL query interface
 * 
 * A modern web interface for running SQL queries against the database.
 * 
 * Usage: node scripts/sql_web.js
 * Then open: http://localhost:3333
 */

import express from 'express';
import Database from 'better-sqlite3';
import { DATABASE_PATH, DATABASE_ENABLED } from '../config.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

if (!DATABASE_ENABLED) {
    console.log('Database is disabled. Enable it in config to use SQL playground.');
    process.exit(1);
}

const db = new Database(DATABASE_PATH, { readonly: false });
db.pragma('journal_mode = WAL');

const app = express();
app.use(express.json());

const PORT = 3333;

// Serve static HTML
app.get('/', (req, res) => {
    res.send(`
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Playground</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e4e4e7;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 25px;
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            font-size: 1.5rem;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .db-info {
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
        }
        
        .sidebar {
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            padding: 15px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .sidebar h3 {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .table-list {
            list-style: none;
        }
        
        .table-list li {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .table-list li:hover {
            background: rgba(96, 165, 250, 0.15);
            color: #60a5fa;
        }
        
        .table-list li .icon { opacity: 0.5; }
        
        .editor-section {
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .CodeMirror {
            height: 200px;
            font-size: 14px;
            border-radius: 0;
        }
        
        .btn {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(96, 165, 250, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #e4e4e7;
        }
        
        .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
        }
        
        .results-section {
            margin-top: 20px;
            background: rgba(255,255,255,0.03);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        .results-count {
            font-size: 0.85rem;
            color: #94a3b8;
        }
        
        .results-table-wrapper {
            overflow-x: auto;
            overflow-y: auto;
        }
        
        table {
            width: max-content;
            min-width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        th {
            background: rgba(0,0,0,0.3);
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            color: #60a5fa;
            position: sticky;
            top: 0;
            white-space: nowrap;
        }
        
        td {
            padding: 10px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            word-break: break-word !important;
            max-width: 400px;
            vertical-align: top;
        }
        
        tr:hover td {
            background: rgba(96, 165, 250, 0.05);
        }
        
        .null-value {
            color: #6b7280;
            font-style: italic;
        }
        
        .error-msg {
            padding: 20px;
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }
        
        .success-msg {
            padding: 20px;
            color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }
        
        .time-badge {
            font-size: 0.75rem;
            padding: 4px 8px;
            background: rgba(74, 222, 128, 0.15);
            color: #4ade80;
            border-radius: 4px;
        }
        
        .example-queries {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .example-queries h4 {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-bottom: 8px;
        }
        
        .example-query {
            font-size: 0.75rem;
            padding: 6px 10px;
            margin-bottom: 5px;
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .example-query:hover {
            background: rgba(96, 165, 250, 0.15);
        }
        
        .kbd {
            font-size: 0.7rem;
            padding: 2px 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üóÑÔ∏è SQL Playground</h1>
            <div class="db-info">Database: ${DATABASE_PATH}</div>
        </header>
        
        <div class="main-grid">
            <aside class="sidebar">
                <h3>üìã Tables</h3>
                <ul class="table-list" id="tableList">
                    <li onclick="loadTable('users')"><span class="icon">üìÅ</span> users</li>
                    <li onclick="loadTable('user_profiles')"><span class="icon">üìÅ</span> user_profiles</li>
                    <li onclick="loadTable('fb_entities')"><span class="icon">üìÅ</span> fb_entities</li>
                    <li onclick="loadTable('user_work_history')"><span class="icon">üìÅ</span> user_work_history</li>
                    <li onclick="loadTable('user_education_history')"><span class="icon">üìÅ</span> user_education_history</li>
                    <li onclick="loadTable('fb_pages')"><span class="icon">üìÅ</span> fb_pages</li>
                    <li onclick="loadTable('user_page_likes')"><span class="icon">üìÅ</span> user_page_likes</li>
                    <li onclick="loadTable('saved_media')"><span class="icon">üìÅ</span> saved_media</li>
                    <li onclick="loadTable('username_history')"><span class="icon">üìÅ</span> username_history</li>
                </ul>
                
                <div class="example-queries">
                    <h4>‚ö° Quick Queries</h4>
                    <div class="example-query" onclick="setQuery('SELECT * FROM v_user_profiles_full LIMIT 10;')">
                        User profiles with locations
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT * FROM v_user_work;')">
                        Work history
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT * FROM v_user_education;')">
                        Education history
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT * FROM v_user_page_likes LIMIT 100;')">
                        Page likes
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT * FROM v_user_stats;')">
                        User stats
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT entity_type, COUNT(*) as count FROM fb_entities GROUP BY entity_type;')">
                        Entity breakdown
                    </div>
                    <div class="example-query" onclick="searchDaNang()">
                        Search Da Nang
                    </div>
                    
                    <h4 style="margin-top:12px">üìà Stats</h4>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as total FROM users;')">
                        Total users
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as total FROM user_profiles;')">
                        Total profiles
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as total FROM fb_entities;')">
                        Total entities
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as total FROM fb_pages;')">
                        Total liked pages
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as total FROM saved_media;')">
                        Total saved media
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT entity_type, COUNT(*) as count FROM fb_entities GROUP BY entity_type ORDER BY count DESC;')">
                        Entity breakdown
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT COUNT(*) as users, (SELECT COUNT(*) FROM user_profiles) as profiles, (SELECT COUNT(*) FROM fb_entities) as entities, (SELECT COUNT(*) FROM fb_pages) as pages, (SELECT COUNT(*) FROM saved_media) as media, (SELECT COUNT(*) FROM user_page_likes) as likes FROM users;')">
                        All counts
                    </div>
                    
                    <h4 style="margin-top:12px">üîç Search</h4>
                    <div class="example-query" onclick="searchByName()">
                        Search by name
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT u.uid, up.name, fe.name as location FROM users u JOIN user_profiles up ON u.id = up.user_id JOIN fb_entities fe ON up.current_location_id = fe.id;')">
                        Users with locations
                    </div>
                    <div class="example-query" onclick="setQuery('SELECT u.uid, up.name, COUNT(upl.id) as likes_count FROM users u JOIN user_profiles up ON u.id = up.user_id LEFT JOIN user_page_likes upl ON u.id = upl.user_id GROUP BY u.id ORDER BY likes_count DESC;')">
                        Users by likes count
                    </div>
                </div>
            </aside>
            
            <main>
                <div class="editor-section">
                    <div class="editor-header">
                        <span>SQL Query <span class="kbd">Ctrl+Enter</span> to run</span>
                        <div>
                            <button class="btn btn-secondary" onclick="clearEditor()">Clear</button>
                            <button class="btn btn-primary" onclick="runQuery()">‚ñ∂ Run Query</button>
                        </div>
                    </div>
                    <textarea id="sqlEditor">SELECT * FROM users LIMIT 10;</textarea>
                </div>
                
                <div class="results-section" id="resultsSection">
                    <div class="results-header">
                        <span>Results</span>
                        <div>
                            <span class="results-count" id="resultsCount"></span>
                            <span class="time-badge" id="queryTime"></span>
                        </div>
                    </div>
                    <div class="results-table-wrapper" id="resultsWrapper">
                        <div style="padding: 40px; text-align: center; color: #6b7280;">
                            Run a query to see results
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"><\/script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"><\/script>
    <script>
        let editor;
        
        document.addEventListener('DOMContentLoaded', () => {
            editor = CodeMirror.fromTextArea(document.getElementById('sqlEditor'), {
                mode: 'text/x-sql',
                theme: 'dracula',
                lineNumbers: true,
                autofocus: true,
                extraKeys: {
                    'Ctrl-Enter': runQuery,
                    'Cmd-Enter': runQuery
                }
            });
        });
        
        function setQuery(sql) {
            editor.setValue(sql);
        }
        
        function searchDaNang() {
            editor.setValue("SELECT * FROM fb_entities WHERE name LIKE '%Da Nang%';");
        }
        
        function searchByName() {
            editor.setValue("SELECT * FROM user_profiles WHERE name LIKE '%YOUR_SEARCH_TERM%';");
        }
        
        function loadTable(tableName) {
            setQuery('SELECT * FROM ' + tableName + ' LIMIT 100;');
            runQuery();
        }
        
        function clearEditor() {
            editor.setValue('');
        }
        
        async function runQuery() {
            const sql = editor.getValue().trim();
            if (!sql) return;
            
            const startTime = performance.now();
            
            try {
                const response = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sql })
                });
                
                const result = await response.json();
                const elapsed = (performance.now() - startTime).toFixed(0);
                
                document.getElementById('queryTime').textContent = elapsed + 'ms';
                
                if (result.error) {
                    document.getElementById('resultsCount').textContent = 'Error';
                    document.getElementById('resultsWrapper').innerHTML = 
                        '<div class="error-msg">‚ùå ' + escapeHtml(result.error) + '</div>';
                } else if (result.message) {
                    document.getElementById('resultsCount').textContent = 'Success';
                    document.getElementById('resultsWrapper').innerHTML = 
                        '<div class="success-msg">‚úì ' + escapeHtml(result.message) + '</div>';
                } else {
                    renderResults(result.data);
                }
            } catch (error) {
                document.getElementById('resultsWrapper').innerHTML = 
                    '<div class="error-msg">‚ùå ' + escapeHtml(error.message) + '</div>';
            }
        }
        
        function renderResults(data) {
            if (!data || data.length === 0) {
                document.getElementById('resultsCount').textContent = '0 rows';
                document.getElementById('resultsWrapper').innerHTML = 
                    '<div style="padding: 40px; text-align: center; color: #6b7280;">No results</div>';
                return;
            }
            
            const columns = Object.keys(data[0]);
            document.getElementById('resultsCount').textContent = data.length + ' row' + (data.length !== 1 ? 's' : '');
            
            let html = '<table><thead><tr>';
            columns.forEach(col => {
                html += '<th>' + escapeHtml(col) + '</th>';
            });
            html += '</tr></thead><tbody>';
            
            data.forEach(row => {
                html += '<tr>';
                columns.forEach(col => {
                    const val = row[col];
                    if (val === null) {
                        html += '<td class="null-value">NULL</td>';
                    } else {
                        html += '<td title="' + escapeHtml(String(val)) + '">' + escapeHtml(String(val)) + '</td>';
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            document.getElementById('resultsWrapper').innerHTML = html;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    <\/script>
</body>
</html>
    `);
});

// API endpoint for queries
app.post('/api/query', (req, res) => {
    const { sql } = req.body;

    if (!sql) {
        return res.json({ error: 'No SQL query provided' });
    }

    try {
        const trimmed = sql.trim();
        const isSelect = /^\s*(SELECT|PRAGMA|EXPLAIN)/i.test(trimmed);

        if (isSelect) {
            const rows = db.prepare(trimmed).all();
            res.json({ data: rows });
        } else {
            db.exec(trimmed);
            res.json({ message: 'Query executed successfully' });
        }
    } catch (error) {
        res.json({ error: error.message });
    }
});

// API to list tables
app.get('/api/tables', (req, res) => {
    try {
        const tables = db.prepare(`
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name NOT LIKE 'sqlite_%'
            ORDER BY name
        `).all();
        res.json(tables);
    } catch (error) {
        res.json({ error: error.message });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üóÑÔ∏è  SQL Playground Web Interface                        ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                          ‚ïë
‚ïë  Open in browser: http://localhost:${PORT}                 ‚ïë
‚ïë                                                          ‚ïë
‚ïë  Press Ctrl+C to stop                                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);
});

// Cleanup on exit
process.on('SIGINT', () => {
    db.close();
    process.exit();
});

```

### scripts\token_manager.js
```js
import { getDatabase } from './database.js';
import { DATABASE_ENABLED, PLATFORM_FACEBOOK } from '../config.js';
import { log } from './logger.js';

/**
 * TokenManager - Handles multi-token load balancing and usage tracking
 */
class TokenManager {
    /**
     * Get next available token using Round Robin + least-used strategy
     * @param {number} platformId - Platform ID (1=Facebook, 2=Instagram)
     * @returns {object|null} {token, tokenId} or null
     */
    static getToken(platformId = PLATFORM_FACEBOOK) {
        if (!DATABASE_ENABLED) return null;

        const db = getDatabase();
        if (!db) return null;

        try {
            // Get all active tokens that are not rate limited
            // Order by priority (desc), then requests_made (asc) for load balancing
            const result = db.prepare(`
        SELECT id, token
        FROM access_tokens
        WHERE platform_id = ? 
          AND is_active = 1
          AND (is_rate_limited = 0 OR rate_limit_reset IS NULL OR rate_limit_reset < datetime('now'))
        ORDER BY priority DESC, requests_made ASC
        LIMIT 1
      `).get(platformId);

            if (result) {
                // Update last_request timestamp
                db.prepare(`
          UPDATE access_tokens
          SET last_request = datetime('now')
          WHERE id = ?
        `).run(result.id);

                return {
                    token: result.token,
                    tokenId: result.id
                };
            }

            return null;
        } catch (error) {
            log(`‚ö†Ô∏è Error getting token: ${error.message}`);
            return null;
        }
    }

    /**
     * Record token usage for analytics and load balancing
     * @param {number} tokenId - Token ID
     * @param {string} endpoint - API endpoint (e.g., '/me/photos')
     * @param {boolean} success - Whether request was successful
     * @param {number} httpStatus - HTTP status code
     * @param {number} responseTime - Response time in milliseconds
     * @param {string} error - Error message if failed
     */
    static recordUsage(tokenId, endpoint, success, httpStatus = null, responseTime = null, error = null) {
        if (!DATABASE_ENABLED || !tokenId) return;

        const db = getDatabase();
        if (!db) return;

        try {
            // Log to usage_log
            db.prepare(`
        INSERT INTO token_usage_log (token_id, endpoint, success, http_status, response_time_ms, error_message)
        VALUES (?, ?, ?, ? ,?, ?)
      `).run(tokenId, endpoint, success ? 1 : 0, httpStatus, responseTime, error);

            // Increment requests_made counter
            db.prepare(`
        UPDATE access_tokens
        SET requests_made = requests_made + 1,
            last_used = datetime('now')
        WHERE id = ?
      `).run(tokenId);

        } catch (error) {
            log(`‚ö†Ô∏è Error recording usage: ${error.message}`);
        }
    }

    /**
     * Mark token as rate limited
     * @param {number} tokenId - Token ID
     * @param {string} resetTime - ISO timestamp when rate limit resets
     */
    static markRateLimited(tokenId, resetTime = null) {
        if (!DATABASE_ENABLED || !tokenId) return;

        const db = getDatabase();
        if (!db) return;

        try {
            const reset = resetTime || new Date(Date.now() + 60 * 60 * 1000).toISOString(); // Default: 1 hour

            db.prepare(`
        UPDATE access_tokens
        SET is_rate_limited = 1,
            rate_limit_reset = ?
        WHERE id = ?
      `).run(reset, tokenId);

            log(`‚ö†Ô∏è Token ${tokenId} marked as rate limited until ${reset}`);
        } catch (error) {
            log(`‚ö†Ô∏è Error marking rate limit: ${error.message}`);
        }
    }

    /**
     * Clear rate limit flag (called when reset time has passed)
     * @param {number} tokenId - Token ID
     */
    static clearRateLimit(tokenId) {
        if (!DATABASE_ENABLED || !tokenId) return;

        const db = getDatabase();
        if (!db) return;

        try {
            db.prepare(`
        UPDATE access_tokens
        SET is_rate_limited = 0,
            rate_limit_reset = NULL
        WHERE id = ?
      `).run(tokenId);

            log(`‚úÖ Rate limit cleared for token ${tokenId}`);
        } catch (error) {
            log(`‚ö†Ô∏è Error clearing rate limit: ${error.message}`);
        }
    }

    /**
     * Get analytics for all active tokens
     * @returns {Array} Array of token analytics
     */
    static getAnalytics() {
        if (!DATABASE_ENABLED) return [];

        const db = getDatabase();
        if (!db) return [];

        try {
            return db.prepare(`
        SELECT * FROM v_token_analytics
        ORDER BY priority DESC, total_api_requests DESC
      `).all();
        } catch (error) {
            log(`‚ö†Ô∏è Error getting analytics: ${error.message}`);
            return [];
        }
    }

    /**
     * Get endpoint statistics
     * @param {number} days - Number of days to look back (default: 7)
     * @returns {Array} Array of endpoint statistics
     */
    static getEndpointStats(days = 7) {
        if (!DATABASE_ENABLED) return [];

        const db = getDatabase();
        if (!db) return [];

        try {
            return db.prepare(`
        SELECT 
          endpoint,
          COUNT(*) as total_requests,
          ROUND(AVG(response_time_ms), 2) as avg_response_time,
          SUM(CASE WHEN success = 1 THEN 1 ELSE 0 END) as successes,
          ROUND(AVG(CASE WHEN success = 1 THEN 100.0 ELSE 0 END), 2) as success_rate
        FROM token_usage_log
        WHERE created_at > datetime('now', '-' || ? || ' days')
        GROUP BY endpoint
        ORDER BY total_requests DESC
        LIMIT 10
      `).all(days);
        } catch (error) {
            log(`‚ö†Ô∏è Error getting endpoint stats: ${error.message}`);
            return [];
        }
    }
}

export default TokenManager;

```

### scripts\token_validator.js
```js
import fetch from 'node-fetch';
import { FB_API_HOST, S } from './constants.js';
import { ACCESS_TOKEN, PLATFORM_FACEBOOK } from '../config.js';
import { log } from './logger.js';
import { getSharedReadline } from './shared_readline.js';

// Use shared readline - DO NOT create separate instance
const prompt = (query) =>
    new Promise((resolve) => getSharedReadline().question(S.FgGreen + query + S.Reset, resolve));

/**
 * Validate token with Facebook API
 * @param {string} token - Access token to validate
 * @returns {Promise<object>} Validation result {valid, user, error}
 */
export const validateTokenWithAPI = async (token) => {
    try {
        const response = await fetch(`${FB_API_HOST}/me?access_token=${token}`);
        const data = await response.json();

        if (data.error) {
            return {
                valid: false,
                error: data.error.message,
                errorCode: data.error.code
            };
        }

        return {
            valid: true,
            user: {
                id: data.id,
                name: data.name
            }
        };
    } catch (error) {
        return {
            valid: false,
            error: error.message
        };
    }
};

/**
 * Get token permissions from Facebook API
 * @param {string} token - Access token
 * @returns {Promise<Array>} Array of granted permissions
 */
export const getTokenPermissions = async (token) => {
    try {
        const response = await fetch(`${FB_API_HOST}/me/permissions?access_token=${token}`);
        const data = await response.json();

        if (data.error) {
            return [];
        }

        // Filter only granted permissions
        const granted = data.data
            .filter(p => p.status === 'granted')
            .map(p => p.permission);

        return granted;
    } catch (error) {
        log(`‚ö†Ô∏è Error fetching permissions: ${error.message}`);
        return [];
    }
};

/**
 * Check if token has required permissions
 * @param {Array<string>} permissions - Array of permissions
 * @returns {object} Check result {hasRequired, hasRecommended, missing}
 */
export const checkRequiredPermissions = (permissions) => {
    const ESSENTIAL = ['user_photos', 'user_posts'];
    const RECOMMENDED = ['user_videos'];

    const permSet = new Set(permissions);
    const missingEssential = ESSENTIAL.filter(p => !permSet.has(p));
    const missingRecommended = RECOMMENDED.filter(p => !permSet.has(p));

    return {
        hasRequired: missingEssential.length === 0,
        hasRecommended: missingRecommended.length === 0,
        missingEssential,
        missingRecommended,
        granted: permissions
    };
};

/**
 * Permission descriptions in Vietnamese
 */
const PERMISSION_DESCRIPTIONS = {
    // User data
    'user_photos': '·∫¢nh c·ªßa ng∆∞·ªùi d√πng',
    'user_posts': 'B√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng',
    'user_videos': 'Video c·ªßa ng∆∞·ªùi d√πng',
    'user_about_me': 'Th√¥ng tin gi·ªõi thi·ªáu b·∫£n th√¢n',
    'user_birthday': 'Ng√†y sinh',
    'user_education_history': 'L·ªãch s·ª≠ h·ªçc v·∫•n',
    'user_events': 'S·ª± ki·ªán c·ªßa ng∆∞·ªùi d√πng',
    'user_friends': 'Danh s√°ch b·∫°n b√®',
    'user_hometown': 'Qu√™ qu√°n',
    'user_likes': 'C√°c trang ƒë√£ th√≠ch',
    'user_location': 'V·ªã tr√≠ hi·ªán t·∫°i',
    'user_messenger_contact': 'Li√™n h·ªá Messenger',
    'user_relationship_details': 'Chi ti·∫øt m·ªëi quan h·ªá',
    'user_relationships': 'T√¨nh tr·∫°ng m·ªëi quan h·ªá',
    'user_religion_politics': 'T√¥n gi√°o v√† ch√≠nh tr·ªã',
    'user_website': 'Website c√° nh√¢n',
    'user_work_history': 'L·ªãch s·ª≠ c√¥ng vi·ªác',
    'user_managed_groups': 'Nh√≥m do ng∆∞·ªùi d√πng qu·∫£n l√Ω',
    'user_age_range': 'ƒê·ªô tu·ªïi',
    'user_gender': 'Gi·ªõi t√≠nh',
    'user_link': 'Li√™n k·∫øt h·ªì s∆°',
    'user_groups': 'Nh√≥m',

    // Profile & Auth
    'public_profile': 'Th√¥ng tin c√¥ng khai (t√™n, ·∫£nh ƒë·∫°i di·ªán)',
    'email': 'ƒê·ªãa ch·ªâ email',
    'openid': 'X√°c th·ª±c OpenID',
    'offline_access': 'Truy c·∫≠p ngo·∫°i tuy·∫øn (token d√†i h·∫°n)',

    // Ads
    'ads_management': 'Qu·∫£n l√Ω qu·∫£ng c√°o',
    'ads_read': 'ƒê·ªçc qu·∫£ng c√°o',
    'attribution_read': 'ƒê·ªçc d·ªØ li·ªáu ph√¢n b·ªï qu·∫£ng c√°o',
    'read_ads_dataset_quality': 'ƒê·ªçc ch·∫•t l∆∞·ª£ng dataset qu·∫£ng c√°o',
    'paid_marketing_messages': 'Tin nh·∫Øn marketing tr·∫£ ph√≠',

    // Business
    'business_management': 'Qu·∫£n l√Ω doanh nghi·ªáp',
    'business_creative_transfer': 'Chuy·ªÉn n·ªôi dung s√°ng t·∫°o doanh nghi·ªáp',

    // Commerce
    'catalog_management': 'Qu·∫£n l√Ω danh m·ª•c s·∫£n ph·∫©m',
    'commerce_account_manage_orders': 'Qu·∫£n l√Ω ƒë∆°n h√†ng',
    'commerce_account_read_orders': 'ƒê·ªçc ƒë∆°n h√†ng',
    'commerce_account_read_reports': 'ƒê·ªçc b√°o c√°o th∆∞∆°ng m·∫°i',
    'commerce_account_read_settings': 'ƒê·ªçc c√†i ƒë·∫∑t th∆∞∆°ng m·∫°i',

    // Pages
    'pages_show_list': 'Xem danh s√°ch trang qu·∫£n l√Ω',
    'pages_read_engagement': 'ƒê·ªçc t∆∞∆°ng t√°c trang',
    'pages_read_user_content': 'ƒê·ªçc n·ªôi dung ng∆∞·ªùi d√πng tr√™n trang',
    'pages_manage_posts': 'Qu·∫£n l√Ω b√†i ƒëƒÉng trang',
    'pages_manage_ads': 'Qu·∫£n l√Ω qu·∫£ng c√°o trang',
    'pages_manage_cta': 'Qu·∫£n l√Ω n√∫t k√™u g·ªçi h√†nh ƒë·ªông',
    'pages_manage_engagement': 'Qu·∫£n l√Ω t∆∞∆°ng t√°c trang',
    'pages_manage_instant_articles': 'Qu·∫£n l√Ω b√†i vi·∫øt t·ª©c th√¨',
    'pages_manage_metadata': 'Qu·∫£n l√Ω metadata trang',
    'pages_manage_store_location': 'Qu·∫£n l√Ω v·ªã tr√≠ c·ª≠a h√†ng',
    'pages_messaging': 'Nh·∫Øn tin t·ª´ trang',
    'pages_messaging_phone_number': 'Nh·∫Øn tin qua s·ªë ƒëi·ªán tho·∫°i',
    'pages_messaging_subscriptions': 'ƒêƒÉng k√Ω nh·∫Øn tin trang',
    'pages_utility_messaging': 'Tin nh·∫Øn ti·ªán √≠ch trang',
    'page_events': 'S·ª± ki·ªán c·ªßa trang',
    'page_store_location_read': 'ƒê·ªçc v·ªã tr√≠ c·ª≠a h√†ng',
    'read_page_mailboxes': 'ƒê·ªçc h·ªôp th∆∞ trang',
    'publish_to_groups': 'ƒêƒÉng l√™n nh√≥m',
    'publish_pages': 'ƒêƒÉng l√™n trang',

    // Insights
    'read_insights': 'ƒê·ªçc th·ªëng k√™',
    'read_audience_network_insights': 'ƒê·ªçc th·ªëng k√™ Audience Network',

    // Instagram
    'instagram_basic': 'Truy c·∫≠p Instagram c∆° b·∫£n',
    'instagram_content_publish': 'ƒêƒÉng n·ªôi dung Instagram',
    'instagram_manage_comments': 'Qu·∫£n l√Ω b√¨nh lu·∫≠n Instagram',
    'instagram_manage_insights': 'Th·ªëng k√™ Instagram',
    'instagram_manage_events': 'Qu·∫£n l√Ω s·ª± ki·ªán Instagram',
    'instagram_manage_messages': 'Qu·∫£n l√Ω tin nh·∫Øn Instagram',
    'instagram_manage_upcoming_events': 'S·ª± ki·ªán s·∫Øp t·ªõi Instagram',
    'instagram_shopping_tag_products': 'G·∫Øn th·∫ª s·∫£n ph·∫©m Shopping',
    'instagram_branded_content_ads_brand': 'Qu·∫£ng c√°o n·ªôi dung th∆∞∆°ng hi·ªáu',
    'instagram_branded_content_brand': 'N·ªôi dung th∆∞∆°ng hi·ªáu (Brand)',
    'instagram_branded_content_creator': 'N·ªôi dung th∆∞∆°ng hi·ªáu (Creator)',
    'instagram_creator_marketplace_discovery': 'Kh√°m ph√° Creator Marketplace',
    'instagram_creator_marketplace_messaging': 'Nh·∫Øn tin Creator Marketplace',

    // Threads
    'threads_business_basic': 'Threads Business c∆° b·∫£n',
    'threads_location_tagging': 'G·∫Øn th·∫ª v·ªã tr√≠ Threads',
    'threads_profile_discovery': 'Kh√°m ph√° h·ªì s∆° Threads',

    // WhatsApp
    'whatsapp_business_manage_events': 'Qu·∫£n l√Ω s·ª± ki·ªán WhatsApp',
    'whatsapp_business_management': 'Qu·∫£n l√Ω WhatsApp Business',
    'whatsapp_business_messaging': 'Nh·∫Øn tin WhatsApp Business',

    // Other
    'gaming_user_locale': 'Ng√¥n ng·ªØ ng∆∞·ªùi d√πng game',
    'leads_retrieval': 'Truy xu·∫•t kh√°ch h√†ng ti·ªÅm nƒÉng',
    'manage_app_solution': 'Qu·∫£n l√Ω gi·∫£i ph√°p ·ª©ng d·ª•ng',
    'manage_fundraisers': 'Qu·∫£n l√Ω chi·∫øn d·ªãch g√¢y qu·ªπ',
    'private_computation_access': 'Truy c·∫≠p t√≠nh to√°n ri√™ng t∆∞',
    'publish_video': 'ƒêƒÉng video',
    'read_custom_friendlists': 'ƒê·ªçc danh s√°ch b·∫°n b√® t√πy ch·ªânh',
    'rsvp_event': 'Ph·∫£n h·ªìi s·ª± ki·ªán',
    'test_expanded_granular': 'Quy·ªÅn ki·ªÉm tra (dev)',
    'xmpp_login': 'ƒêƒÉng nh·∫≠p XMPP (chat)',
    'facebook_creator_marketplace_discovery': 'Kh√°m ph√° Creator Marketplace FB',
};

/**
 * Display comprehensive token status at startup
 * @param {string} token - Access token
 * @param {object} validation - Validation result from validateTokenWithAPI
 * @param {Array} permissions - Array of granted permissions
 */
export const displayTokenStatus = (token, validation, permissions) => {
    console.log('\n' + S.FgCyan + '‚îÅ'.repeat(70) + S.Reset);
    console.log(S.FgCyan + '  üîë ACCESS TOKEN STATUS' + S.Reset);
    console.log(S.FgCyan + '‚îÅ'.repeat(70) + S.Reset);

    // Token validity
    if (validation.valid) {
        console.log(S.FgGreen + '  ‚úÖ Status: VALID' + S.Reset);
        console.log(`  üë§ User: ${validation.user.name}`);
        console.log(`  üÜî User ID: ${validation.user.id}`);
    } else {
        console.log(S.BgRed + '  ‚ùå Status: INVALID' + S.Reset);
        console.log(S.FgRed + `  Error: ${validation.error}` + S.Reset);
        console.log(S.FgCyan + '‚îÅ'.repeat(70) + S.Reset + '\n');
        return;
    }

    // Token preview (masked)
    const tokenPreview = token.substring(0, 10) + '...' + token.substring(token.length - 10);
    console.log(`  üîê Token: ${tokenPreview}`);

    // Permissions - show ALL with Vietnamese descriptions
    console.log('\n  üìã Permissions (' + permissions.length + ' total):');
    console.log(S.FgCyan + '  ' + '‚îÄ'.repeat(66) + S.Reset);

    // Sort permissions alphabetically
    const sortedPerms = [...permissions].sort((a, b) => a.localeCompare(b));

    sortedPerms.forEach(perm => {
        const description = PERMISSION_DESCRIPTIONS[perm] || 'Quy·ªÅn Facebook';
        const icon = S.FgGreen + '‚úì' + S.Reset;
        const permDisplay = perm.padEnd(38);
        console.log(`     ${icon} ${permDisplay} ${description}`);
    });

    console.log(S.FgCyan + '‚îÅ'.repeat(70) + S.Reset + '\n');
};

/**
 * Interactive token input with masking
 * @returns {Promise<string>} Entered token
 */
export const promptForToken = async () => {
    console.log('\n' + S.FgYellow + '‚îÅ'.repeat(60) + S.Reset);
    console.log(S.FgYellow + '  ACCESS TOKEN REQUIRED' + S.Reset);
    console.log(S.FgYellow + '‚îÅ'.repeat(60) + S.Reset);
    console.log('\nTo use this downloader, you need a Facebook access token.');
    console.log('Get one from: ' + S.FgCyan + 'https://developers.facebook.com/tools/explorer/' + S.Reset);
    console.log('\nSteps:');
    console.log('  1. Visit the Graph API Explorer');
    console.log('  2. Click "Generate Access Token"');
    console.log('  3. Grant permissions: user_photos, user_posts, user_videos');
    console.log('  4. Copy the token and paste it below\n');

    const token = await prompt('> Enter your access token: ');
    return token.trim();
};

/**
 * Validate and save token
 * @param {string} token - Token to validate
 * @returns {Promise<boolean>} Success status
 */
export const validateAndSaveToken = async (token) => {
    console.log(S.FgCyan + '\nüîç Validating token...' + S.Reset);

    // Validate token
    const validation = await validateTokenWithAPI(token);

    if (!validation.valid) {
        console.log(S.BgRed + '\n‚ùå Token validation failed!' + S.Reset);
        console.log(S.FgRed + `Error: ${validation.error}` + S.Reset);
        return false;
    }

    console.log(S.FgGreen + '‚úÖ Token is valid!' + S.Reset);
    console.log(`   User: ${validation.user.name} (ID: ${validation.user.id})`);

    // Get permissions
    console.log(S.FgCyan + 'üîç Checking permissions...' + S.Reset);
    const permissions = await getTokenPermissions(token);
    const permCheck = checkRequiredPermissions(permissions);

    if (!permCheck.hasRequired) {
        console.log(S.BgRed + '\n‚ùå Missing required permissions!' + S.Reset);
        console.log(S.FgRed + 'Missing: ' + permCheck.missingEssential.join(', ') + S.Reset);
        console.log('\nPlease generate a new token with these permissions:');
        console.log('  - user_photos');
        console.log('  - user_posts');
        console.log('  - user_videos (recommended)');
        return false;
    }

    console.log(S.FgGreen + '‚úÖ Permissions verified!' + S.Reset);
    console.log(`   Granted: ${permissions.slice(0, 5).join(', ')}${permissions.length > 5 ? `, +${permissions.length - 5} more` : ''}`);

    if (!permCheck.hasRecommended) {
        console.log(S.FgYellow + '‚ö†Ô∏è  Recommended permission missing: user_videos' + S.Reset);
        console.log('   (Video downloads may not work)');
    }

    // Save token to database
    console.log(S.FgCyan + '\nüíæ Saving token to database...' + S.Reset);
    const saved = saveToken(PLATFORM_FACEBOOK, token, permissions, 'User-entered token');

    if (saved) {
        console.log(S.FgGreen + '‚úÖ Token saved successfully!\n' + S.Reset);
        return true;
    } else {
        console.log(S.BgRed + '‚ùå Failed to save token to database' + S.Reset);
        return false;
    }
};

/**
 * Main token validation flow for startup
 * @returns {Promise<boolean>} True if valid token available, false otherwise
 */
export const ensureValidToken = async () => {
    // Use ACCESS_TOKEN from config (loaded from .env)
    const existingToken = ACCESS_TOKEN;

    if (!existingToken || existingToken.trim() === '') {
        console.log(S.BgYellow + '\n‚ö†Ô∏è  No access token found in .env file!' + S.Reset);
        console.log('Please add FB_ACCESS_TOKEN to your .env file.');
        console.log('Get a token from: ' + S.FgCyan + 'https://developers.facebook.com/tools/explorer/' + S.Reset);
        return false;
    }

    console.log(S.FgCyan + 'üîç Validating access token...' + S.Reset);

    try {
        const validation = await validateTokenWithAPI(existingToken);

        if (validation.valid) {
            const permissions = await getTokenPermissions(existingToken);

            // Display comprehensive token status
            displayTokenStatus(existingToken, validation, permissions);

            return true;
        }

        // Token is invalid
        console.log(S.BgRed + '\n‚ùå Access token is invalid or expired' + S.Reset);
        console.log(S.FgRed + `Error: ${validation.error}` + S.Reset);
        console.log('\nPlease update FB_ACCESS_TOKEN in your .env file with a valid token.');
        return false;

    } catch (error) {
        console.log(S.FgYellow + '‚ö†Ô∏è  Could not validate token: ' + error.message + S.Reset);
        console.log('Proceeding anyway - validation will occur on first API call.');
        return true; // Allow proceeding on network errors
    }
};

/**
 * Close readline interface (deprecated - using shared readline now)
 * This function is kept for compatibility but does nothing
 * The shared readline will be closed when the application exits
 */
export const closeTokenValidator = () => {
    return Promise.resolve();
};

```

### scripts\user_info.js
```js
import { FB_API_HOST } from './constants.js';
import { ACCESS_TOKEN, PLATFORM_FACEBOOK } from '../config.js';
import { myFetch } from './utils.js';
import { log } from './logger.js';
import {
    hasUsername,
    getOrCreateUser,
    saveUsername,
    getAllUIDs,
    getUserIdByUID
} from './database.js';

/**
 * Fetch user info (id, name) from Facebook API
 * @param {string} uid - User's UID
 * @returns {Promise<object|null>} {id, name} or null on error
 */
export const fetchUserInfo = async (uid) => {
    try {
        const url = `${FB_API_HOST}/${uid}?fields=id,name&access_token=${ACCESS_TOKEN}`;
        const data = await myFetch(url);

        if (!data || !data.name) {
            return null;
        }

        return {
            id: data.id,
            name: data.name
        };
    } catch (error) {
        log(`‚ö†Ô∏è Error fetching user info for ${uid}: ${error.message}`);
        return null;
    }
};

/**
 * Ensure a UID has a username stored. If not, fetch and save it.
 * @param {string} uid - User's UID
 * @param {number} platformId - Platform ID (default: 1 for Facebook)
 * @returns {Promise<object>} {userId, username, fetched: boolean, error?: string}
 */
export const ensureUsername = async (uid, platformId = PLATFORM_FACEBOOK) => {
    // Check if username already exists
    const existing = hasUsername(uid, platformId);

    if (existing.hasUsername) {
        return {
            userId: existing.userId,
            username: existing.username,
            fetched: false
        };
    }

    // Need to fetch username from API
    log(`üì° Fetching username for UID: ${uid}...`);
    const userInfo = await fetchUserInfo(uid);

    if (!userInfo || !userInfo.name) {
        return {
            userId: existing.userId,
            username: null,
            fetched: false,
            error: 'Could not fetch username from API'
        };
    }

    // Get or create user in database
    let userId = existing.userId;
    if (!userId) {
        userId = getOrCreateUser(platformId, uid);
    }

    if (!userId) {
        return {
            userId: null,
            username: userInfo.name,
            fetched: true,
            error: 'Could not create user in database'
        };
    }

    // Save username to database
    const profileUrl = `https://www.facebook.com/${uid}`;
    saveUsername(userId, userInfo.name, profileUrl);

    log(`‚úÖ Saved username: ${userInfo.name} for UID: ${uid}`);

    return {
        userId,
        username: userInfo.name,
        fetched: true
    };
};

/**
 * Scan all UIDs in database and fetch missing usernames
 * @param {function} progressCallback - Optional callback for progress updates (current, total, uid, username)
 * @returns {Promise<object>} {total, fetched, skipped, errors}
 */
export const scanAllUIDs = async (progressCallback = null) => {
    const allUIDs = getAllUIDs();
    const stats = {
        total: allUIDs.length,
        fetched: 0,
        skipped: 0,
        errors: 0
    };

    if (allUIDs.length === 0) {
        log('üìã No UIDs found in database.');
        return stats;
    }

    log(`\nüìã Scanning ${allUIDs.length} UIDs for missing usernames...\n`);

    for (let i = 0; i < allUIDs.length; i++) {
        const uid = allUIDs[i];
        const existing = hasUsername(uid);

        if (existing.hasUsername) {
            stats.skipped++;
            if (progressCallback) {
                progressCallback(i + 1, allUIDs.length, uid, existing.username, 'skipped');
            }
            continue;
        }

        // Small delay to avoid rate limiting
        if (stats.fetched > 0) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        const result = await ensureUsername(uid);

        if (result.error) {
            stats.errors++;
            if (progressCallback) {
                progressCallback(i + 1, allUIDs.length, uid, null, 'error');
            }
        } else if (result.fetched) {
            stats.fetched++;
            if (progressCallback) {
                progressCallback(i + 1, allUIDs.length, uid, result.username, 'fetched');
            }
        }
    }

    log(`\n‚úÖ Scan complete!`);
    log(`   Total UIDs: ${stats.total}`);
    log(`   Fetched: ${stats.fetched}`);
    log(`   Already had username: ${stats.skipped}`);
    log(`   Errors: ${stats.errors}`);

    return stats;
};

```

### scripts\user_profile.js
```js
/**
 * User Profile Module (Legacy Entry Point)
 *
 * This file is maintained for backward compatibility.
 * All functionality has been moved to the profile/ subdirectory.
 * 
 * New code should import from './profile/index.js' directly.
 * @module user_profile
 * @deprecated Use './profile/index.js' instead
 */

// Re-export everything from the new modular structure
export * from './profile/index.js';

```

### scripts\utils.js
```js
import fetch from "node-fetch";
import https from "https";
import fs from "fs";
import { FB_API_HOST } from "./constants.js";
import { ACCESS_TOKEN } from "../config.js";
import { log } from "./logger.js";
import {
  parseRateLimitHeader,
  updateRateLimitUsage,
  handle429Response,
  smartSleep,
  formatRateLimitStatus
} from "./rate_limit_manager.js";
import {
  getProxyAgent,
  rotateProxy,
  isProxyEnabled
} from "./proxy_manager.js";

/**
 * Fetch the largest available photo URL from Facebook API
 * Uses the largest_image field to get the highest resolution version
 * @param {string} photo_id - The Facebook photo ID
 * @returns {Promise<string|undefined>} The URL of the largest image, or undefined if not found
 */
export const getLargestPhotoLink = async (photo_id) => {
  const url = `${FB_API_HOST}/${photo_id}?fields=largest_image&access_token=${ACCESS_TOKEN}`;
  const json = await myFetch(url);
  return json?.largest_image?.source;
};

/**
 * Enhanced fetch with automatic rate limit handling and proxy support
 * - Parses X-App-Usage header to track rate limit usage
 * - Handles 429 responses with smart retry logic
 * - Applies smart delays based on current usage levels
 * - Routes requests through proxy if configured
 * 
 * @param {string} _url - URL to fetch
 * @param {object} options - Optional fetch options
 * @param {number} options.maxRetries - Max retries for 429 errors (default: 3)
 * @param {boolean} options.skipRateLimitDelay - Skip the smart delay after fetch
 * @returns {Promise<object|null>} JSON response or null on error
 */
export const myFetch = async (_url, options = {}) => {
  const { maxRetries = 17, skipRateLimitDelay = false } = options;
  let retryCount = 0;

  while (retryCount <= maxRetries) {
    try {
      // Get proxy agent if enabled
      const agent = getProxyAgent();
      const fetchOptions = agent ? { agent } : {};

      const response = await fetch(_url, fetchOptions);

      // Parse and update rate limit usage from header
      const usage = parseRateLimitHeader(response);
      if (usage) {
        updateRateLimitUsage(usage);
      }

      // Handle rate limit (429 Too Many Requests)
      if (response.status === 429) {
        const waitTime = handle429Response(response);
        log(`‚ö†Ô∏è Rate limited (429). Waiting ${Math.round(waitTime / 1000)}s before retry... (attempt ${retryCount + 1}/${maxRetries + 1})`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        retryCount++;
        continue;
      }

      // Handle other HTTP errors
      if (!response.ok) {
        log(`[!] HTTP Error: ${response.status} ${response.statusText}`);
        return null;
      }

      const json = await response.json();

      if (json.error) {
        // Check if it's a rate limit error in the response body
        if (json.error.code === 4 || json.error.code === 17 || json.error.code === 32) {
          log(`‚ö†Ô∏è Rate limit error in response. Waiting 60s before retry...`);
          await new Promise(resolve => setTimeout(resolve, 60000));
          retryCount++;
          continue;
        }
        log("[!] ERROR", JSON.stringify(json, null, 4));
        return null;
      }

      // Apply smart delay after successful requests (based on current usage)
      if (!skipRateLimitDelay) {
        await smartSleep(false); // Silent delay
      }

      return json;
    } catch (e) {
      // Check for network errors that warrant a retry with proxy rotation
      const isNetworkError = e.code === 'ECONNRESET' ||
        e.code === 'ETIMEDOUT' ||
        e.code === 'ECONNREFUSED' ||
        e.code === 'ENOTFOUND' ||
        e.code === 'EAI_AGAIN' ||
        e.message?.includes('ECONNRESET') ||
        e.message?.includes('socket hang up') ||
        e.message?.includes('proxy rejected') ||
        e.message?.includes('Socks') ||
        e.message?.includes('SOCKS');

      if (isNetworkError && retryCount < maxRetries) {
        retryCount++;
        log(`[!] Network error: ${e.message}. Rotating proxy and retrying... (attempt ${retryCount}/${maxRetries + 1})`);

        // Rotate to a different proxy before retrying
        if (isProxyEnabled()) {
          rotateProxy();
        }

        // Wait a bit before retrying
        await new Promise(resolve => setTimeout(resolve, 2000));
        continue;
      }

      log("[!] ERROR", e.toString());
      return null;
    }
  }

  log(`[!] Max retries (${maxRetries}) exceeded. Giving up.`);
  return null;
};

/**
 * Pause execution for a specified duration
 * @param {number} ms - Duration to sleep in milliseconds
 * @returns {Promise<void>} Resolves after the specified duration
 */
export const sleep = (ms) => {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
};

/**
 * Check if a file exists at the specified path
 * @param {string} fileDir - Path to the file to check
 * @returns {boolean} True if the file exists, false otherwise
 */
export const checkFileExist = (fileDir) => fs.existsSync(fileDir);

/**
 * Delete a file if it exists
 * @param {string} fileDir - Path to the file to delete
 * @returns {boolean|undefined} True if file was deleted, undefined if file didn't exist
 */
export const deleteFile = (fileDir) =>
  checkFileExist(fileDir) && fs.unlinkSync(fileDir);

/**
 * Create a directory if it doesn't already exist
 * Creates parent directories recursively if needed
 * @param {string} dir - Path to the directory to create
 * @returns {void}
 */
export const createIfNotExistDir = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
    log(`> ƒê√£ t·∫°o th∆∞ m·ª•c ${dir}.`);
  }
};

/**
 * Save data to a file
 * @param {string} fileName - Path to the file to save
 * @param {string} data - Content to write to the file
 * @param {boolean} override - If true, overwrite the file; if false, append to it (default: false)
 * @returns {void}
 */
export const saveToFile = (fileName, data, override = false) => {
  try {
    fs.writeFileSync(fileName, data, { flag: override ? "w+" : "a+" });
    log(`> ƒê√£ l∆∞u v√†o file ${fileName}`);
  } catch (err) {
    console.error("[!] ERROR: ", err);
  }
};

/**
 * Download a file with atomic write mechanism
 * Downloads to a temporary file first, then renames to final destination
 * to prevent corrupted partial downloads from being treated as complete files
 *
 * @param {string} url - URL to download from
 * @param {string} destination - Final file path
 * @returns {Promise<boolean>} Resolves to true on success
 */
export const download = (url, destination) =>
  new Promise((resolve, reject) => {
    const tempDestination = `${destination}.tmp`;

    // Clean up any existing temp file from previous failed attempts
    if (fs.existsSync(tempDestination)) {
      try {
        fs.unlinkSync(tempDestination);
      } catch (e) {
        // Ignore cleanup errors
      }
    }

    const file = fs.createWriteStream(tempDestination);

    const cleanupAndReject = (error) => {
      // Close the file stream if still open
      file.destroy();
      // Remove temp file on error
      if (fs.existsSync(tempDestination)) {
        try {
          fs.unlinkSync(tempDestination);
        } catch (e) {
          // Ignore cleanup errors
        }
      }
      reject(error.message || error);
    };

    // Get proxy agent if enabled
    const agent = getProxyAgent();
    const requestOptions = agent ? { agent } : {};

    const request = https.get(url, requestOptions, (response) => {
      // Handle HTTP redirects (3xx status codes)
      if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
        file.destroy();
        if (fs.existsSync(tempDestination)) {
          try {
            fs.unlinkSync(tempDestination);
          } catch (e) {
            // Ignore cleanup errors
          }
        }
        // Follow redirect
        download(response.headers.location, destination).then(resolve).catch(reject);
        return;
      }

      // Check for successful HTTP status
      if (response.statusCode !== 200) {
        cleanupAndReject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
        return;
      }

      response.pipe(file);

      // Handle stream errors
      response.on("error", cleanupAndReject);
      file.on("error", cleanupAndReject);

      file.on("finish", () => {
        file.close(() => {
          try {
            // Atomic rename: move temp file to final destination
            fs.renameSync(tempDestination, destination);
            resolve(true);
          } catch (renameError) {
            cleanupAndReject(renameError);
          }
        });
      });
    });

    request.on("error", cleanupAndReject);

    // Set a timeout to prevent hanging downloads
    request.setTimeout(60000, () => {
      request.destroy();
      cleanupAndReject(new Error("Download timeout (60s)"));
    });
  });

/**
 * Parse comma-separated user IDs for batch downloads
 * @param {string} input - Comma-separated IDs (e.g., "123, 456, 789")
 * @returns {string[]} Array of trimmed IDs
 */
export const parseUserIds = (input) => {
  if (!input || typeof input !== 'string') {
    return [];
  }

  return input
    .split(',')
    .map(id => id.trim())
    .filter(id => id.length > 0);
};

/**
 * Sanitize folder/file name by removing invalid characters
 * @param {string} name - Folder or file name
 * @returns {string} Sanitized name safe for filesystem
 */
export const sanitizeFolderName = (name) => {
  if (!name || typeof name !== 'string') {
    return '(no name)';
  }

  // Replace invalid Windows filename characters: < > : " / \ | ? *
  // Also replace newlines and tabs
  let sanitized = name
    .replace(/[<>:"\/\\|?*\r\n\t]/g, '_')
    .replace(/\s+/g, ' ')  // Replace multiple spaces with single space
    .trim();

  // Limit length to 100 characters (Windows path limit is 260 total)
  if (sanitized.length > 100) {
    sanitized = sanitized.substring(0, 100);
  }

  // If empty after sanitization, use default
  if (!sanitized) {
    return '(no name)';
  }

  return sanitized;
};

/**
 * Save caption/description as a text file next to media file
 * @param {string} mediaPath - Path to media file (without extension)
 * @param {string} caption - Caption/description text
 */
export const saveCaptionFile = (mediaPath, caption) => {
  if (!caption || typeof caption !== 'string' || !caption.trim()) {
    return; // Don't create file for empty captions
  }

  try {
    const captionPath = `${mediaPath}.txt`;
    fs.writeFileSync(captionPath, caption.trim(), 'utf8');
  } catch (error) {
    // Silently fail - caption is nice to have but not critical
    console.error(`Failed to save caption: ${error.message}`);
  }
};

// Re-export rate limit utilities for convenience
export {
  smartSleep,
  formatRateLimitStatus,
  getRateLimitUsage,
  getMaxUsagePercent
} from './rate_limit_manager.js';

```

### scripts\menu\admin.js
```js
/**
 * Admin/Utility Menu Module
 *
 * Handles administrative functions: UIDs, proxy health, language, etc.
 * @module menu/admin
 */

import fs from "fs";
import { prompt, choose, waitForKeyPressed } from "./core.js";
import { S } from "../constants.js";
import { t, LANGKEY, setLang } from "../lang.js";
import { log } from "../logger.js";
import { download, createIfNotExistDir, parseUserIds } from "../utils.js";
import { getAllUIDs } from "../database.js";
import { ensureUsername, scanAllUIDs } from "../user_info.js";
import { ensureUserProfile, fetchAndSaveProfile, fetchUserProfile } from "../user_profile.js";
import { fetchTimeLineAlbumId_FBPage } from "../download_timeline_album.js";
import { fetchAlbumInfo } from "../download_album.js";
import { checkAllProxies, reorderByLatency, isProxyEnabled, getProxyStats, toggleProxy } from "../proxy_manager.js";

/**
 * Menu handler for downloading media from a text file containing URLs
 * Reads URLs from file and downloads each one
 * @returns {Promise<void>}
 */
export const menuDownloadFromFile = async () => {
    const file_path = await prompt(t("enterFilePath"));

    if (file_path) {
        const folder_name = await prompt(t("folderToSave"));
        const folder_path = `downloads/from-file/${folder_name}/`;
        createIfNotExistDir(folder_path);

        try {
            const content = fs.readFileSync(file_path, "utf8");
            const urls = content.split("\n");

            log(t("foundLinks").replace("{length}", urls.length));

            let index = 1;
            for (let url of urls) {
                try {
                    let isPhoto = url.indexOf(".jpg") > 0;
                    let fileName = `${folder_path}/${index}.${isPhoto ? "jpg" : "mp4"}`;

                    log(
                        t("downloadingLinks").replace(
                            "{progress}",
                            `${index}/${urls.length}`
                        )
                    );
                    await download(url, fileName);
                    index++;
                } catch (e) {
                    log(t("errorWhenDownloadUrl").replace("{url}", url), e);
                }
            }
        } catch (e) {
            log(t("error"), e);
        }
    }
};

/**
 * Menu handler for selecting application language
 * Supports Vietnamese and English
 * @returns {Promise<void>}
 */
export const menuSelectLanguage = async () => {
    const action = await choose("Ng√¥n ng·ªØ / Select Language", {
        1: "Ti·∫øng Vi·ªát",
        2: "English",
    });

    if (action.key == 1) {
        setLang(LANGKEY.vi);
    }
    if (action.key == 2) {
        setLang(LANGKEY.en);
    }
};

/**
 * Show timeline album info for a Facebook page
 * @returns {Promise<void>}
 */
export const menuFindTimelineAlbum = async () => {
    const page_id = await prompt(t("enterPageID"));
    if (page_id != -1) {
        // Auto-fetch user profile for the page ID
        await ensureUserProfile(page_id);

        const timeline_album_id = await fetchTimeLineAlbumId_FBPage(page_id);
        if (timeline_album_id) {
            log(t("foundTimelineAlbumID"), timeline_album_id);
            log(t("fetchingAlbumInfo"));
            log(await fetchAlbumInfo(timeline_album_id));
        } else {
            log(S.BgRed + t("notFoundTimlineAlbum") + S.Reset);
        }
        await waitForKeyPressed();
    }
};

/**
 * Print all UIDs from the database
 * @returns {Promise<void>}
 */
export const menuPrintAllUIDs = async () => {
    const uids = getAllUIDs();
    if (uids.length === 0) {
        log("No UIDs found in database.");
    } else {
        log(`\nüìã All UIDs (${uids.length} total):\n`);
        log(uids.join(","));
    }
    await waitForKeyPressed();
};

/**
 * Scan UIDs and fetch missing usernames
 * @returns {Promise<void>}
 */
export const menuScanUIDs = async () => {
    const uid_input = await prompt("Enter UID(s) (comma-separated, or Enter to scan all): ");

    if (uid_input && uid_input.trim()) {
        // Parse comma-separated UIDs
        const uids = parseUserIds(uid_input);

        if (uids.length === 0) {
            log("No valid UIDs entered.");
        } else if (uids.length === 1) {
            // Single UID mode
            const uid = uids[0];
            log(`\nüîç Fetching username for UID: ${uid}...`);
            const result = await ensureUsername(uid);
            if (result.username) {
                log(`‚úÖ ${uid} ‚Üí ${result.username}`);
            } else {
                log(`‚ùå Could not fetch username for ${uid}${result.error ? ': ' + result.error : ''}`);
            }
        } else {
            // Multiple UIDs - batch mode
            log(`\nüîç Fetching usernames for ${uids.length} UIDs...\n`);
            let fetched = 0, skipped = 0, errors = 0;

            for (let i = 0; i < uids.length; i++) {
                const uid = uids[i];
                const result = await ensureUsername(uid);

                if (result.username) {
                    if (result.fetched) {
                        log(`  [${i + 1}/${uids.length}] ‚úÖ ${uid} ‚Üí ${result.username}`);
                        fetched++;
                    } else {
                        log(`  [${i + 1}/${uids.length}] ‚è≠Ô∏è ${uid} ‚Üí ${result.username} (already exists)`);
                        skipped++;
                    }
                } else {
                    log(`  [${i + 1}/${uids.length}] ‚ùå ${uid} ‚Üí Failed`);
                    errors++;
                }

                // Small delay between requests
                if (i < uids.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }

            log(`\nüìä Summary: ${fetched} fetched, ${skipped} already existed, ${errors} errors`);
        }
    } else {
        // Scan all UIDs mode
        log("\nüîç Starting UID username scan for all UIDs...");
        await scanAllUIDs((current, total, uid, username, status) => {
            if (status === 'fetched') {
                log(`  [${current}/${total}] ‚úÖ ${uid} ‚Üí ${username}`);
            } else if (status === 'error') {
                log(`  [${current}/${total}] ‚ùå ${uid} ‚Üí Failed to fetch`);
            }
            // Skip logging for 'skipped' to avoid clutter
        });
    }
    await waitForKeyPressed();
};

/**
 * Proxy health check menu
 * @returns {Promise<void>}
 */
export const menuProxyHealthCheck = async () => {
    const stats = getProxyStats();
    const proxyStatus = isProxyEnabled() ? '‚úÖ ENABLED' : '‚ùå DISABLED';
    log(`\nüìä Proxy Status: ${proxyStatus}`);
    if (isProxyEnabled()) {
        log(`   Loaded: ${stats.total} proxies, ${stats.failed} marked as failed`);
        log(`   Current: ${stats.current || 'none'}`);
    }

    const healthAction = await choose("Proxy Management", {
        0: t("back"),
        1: isProxyEnabled() ? "üî¥ Disable Proxy" : "üü¢ Enable Proxy",
        2: "Test all proxies",
        3: "Test all & remove dead proxies",
        4: "Test all & reorder by speed (fastest first)",
    });

    if (healthAction.key == 1) {
        toggleProxy();
    } else if (healthAction.key >= 2 && healthAction.key <= 4) {
        if (!isProxyEnabled()) {
            log("\n‚ö†Ô∏è Proxy is disabled. Enable it first to run health checks.");
        } else {
            const results = await checkAllProxies({
                timeout: 10000,
                removeDeadProxies: healthAction.key == 3,
                onProgress: (current, total, result) => {
                    const status = result.success ? `‚úÖ ${result.latency}ms` : `‚ùå ${result.error}`;
                    log(`  [${current}/${total}] ${status}`);
                }
            });

            if (healthAction.key == 4 && results.healthy > 0) {
                reorderByLatency(results);
            }
        }
    }

    await waitForKeyPressed();
};

/**
 * Show help/contact information
 * @returns {Promise<void>}
 */
export const menuShowHelp = async () => {
    log(t("contact"));
    await waitForKeyPressed();
};

/**
 * Fetch/Update user profiles with change tracking
 * Supports multiple UIDs (comma-separated)
 * Shows which fields changed for each profile
 * @returns {Promise<void>}
 */
export const menuFetchUserProfiles = async () => {
    const uidInput = await prompt(t("enterUIDsToFetch"));
    if (!uidInput || uidInput.trim() === '' || uidInput === '-1') return;

    // Parse comma-separated UIDs
    const uids = parseUserIds(uidInput);
    if (uids.length === 0) {
        log("No valid UIDs entered.");
        return;
    }

    const includeLikesInput = await prompt(t("includeLikes"));
    const includeLikes = includeLikesInput === '1';

    log(`\n${"‚îÄ".repeat(60)}`);
    log(`  ${t("fetchProfilesTitle")}`);
    log(`  UIDs: ${uids.length} | ${t("includeLikes").split("?")[0]}: ${includeLikes ? 'Yes' : 'No'}`);
    log("‚îÄ".repeat(60));

    const results = { fetched: 0, updated: 0, noChanges: 0, failed: 0 };

    for (let i = 0; i < uids.length; i++) {
        const uid = uids[i];
        log(`\n[${i + 1}/${uids.length}] UID: ${uid}`);

        try {
            const result = await fetchAndSaveProfile(uid, { includeLikes });

            if (result.saved) {
                if (result.isNew) {
                    log(`   ‚úÖ ${t("profileFetched")}: ${result.profile?.name || 'N/A'}`);
                    results.fetched++;
                } else if (result.changedFields && result.changedFields.length > 0) {
                    log(`   üìù ${t("profileUpdated")}: ${result.profile?.name || 'N/A'}`);
                    log(`   ${t("fieldsChanged")}: ${result.changedFields.join(', ')}`);
                    results.updated++;
                } else {
                    log(`   ‚è≠Ô∏è ${t("profileNoChanges")}: ${result.profile?.name || 'N/A'}`);
                    results.noChanges++;
                }
            } else {
                log(`   ‚ùå ${t("profileFailed")}: ${result.reason || 'Unknown error'}`);
                results.failed++;
            }
        } catch (error) {
            log(`   ‚ùå ${t("profileFailed")}: ${error.message}`);
            results.failed++;
        }

        // Small delay between UIDs
        if (i < uids.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    // Summary
    log(`\n${"‚îÄ".repeat(60)}`);
    log(`  üìä Summary:`);
    log(`     New: ${results.fetched} | Updated: ${results.updated} | No changes: ${results.noChanges} | Failed: ${results.failed}`);
    log("‚îÄ".repeat(60));

    await waitForKeyPressed();
};


```

### scripts\menu\album.js
```js
/**
 * Album Download Menu Module
 *
 * Handles the album download submenu and related functionality.
 * @module menu/album
 */

import { prompt, choose, waitForKeyPressed } from "./core.js";
import { t } from "../lang.js";
import { log } from "../logger.js";
import {
    downloadAlbumPhoto,
    downloadAlbumPhotoLinks,
    fetchAlbumInfo,
} from "../download_album.js";
import { runCancellable } from "../cancellation.js";

/**
 * Menu handler for downloading photos from Facebook albums
 * Supports downloading all images or saving image links to file
 * @returns {Promise<void>}
 */
export const menuDownloadAlbum = async () => {
    while (true) {
        const action = await choose(t("downAlbumTitle"), {
            0: t("back"),
            1: t("downloadAllImageInAlbum"),
            2: t("downloadAllLinkInAlbum"),
        });

        if (action.key == 0) break;
        if (action.key == 1 || action.key == 2) {
            const album_id = await prompt(t("enterAlbumID"));
            if (album_id != -1) {
                const from_photo_id_text = await prompt(t("enterStartPhotoID"));
                const largest_photo = await prompt(t("downloadHD"));
                const from_photo_id =
                    from_photo_id_text == "0" ? null : from_photo_id_text;
                const is_largest_photo = largest_photo == "0" ? false : true;

                if (action.key == 2 && is_largest_photo) {
                    log(t("saveHDLinkNotSupported"));
                }

                // Wrap download in cancellable operation
                await runCancellable(async () => {
                    if (action.key == 1) {
                        await downloadAlbumPhoto({
                            albumId: album_id,
                            fromPhotoId: from_photo_id,
                            isGetLargestPhoto: is_largest_photo,
                        });
                    } else {
                        await downloadAlbumPhotoLinks({
                            albumId: album_id,
                            fromPhotoId: from_photo_id,
                            isGetLargestPhoto: is_largest_photo,
                        });
                    }
                });
            }
        }
    }
};

/**
 * Show album information for a given album ID
 * @returns {Promise<void>}
 */
export const showAlbumInfo = async () => {
    const album_id = await prompt(t("enterAlbumID"));
    if (album_id != -1) {
        log(await fetchAlbumInfo(album_id));
        await waitForKeyPressed();
    }
};

```

### scripts\menu\core.js
```js
/**
 * Menu Core Utilities Module
 *
 * Provides core menu functionality: prompts, choices, and shared readline.
 * @module menu/core
 */

import readline from "readline";
import { S } from "../constants.js";
import { t } from "../lang.js";
import { log } from "../logger.js";

/**
 * Readline interface for user input
 * @type {readline.Interface}
 */
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
});

/**
 * Display a prompt and wait for user input
 * @param {string} query - The prompt text to display
 * @returns {Promise<string>} User's input response
 */
export const prompt = (query) =>
    new Promise((resolve) => rl.question(S.FgGreen + query + S.Reset, resolve));

/**
 * Wait for user to press any key before continuing
 * @returns {Promise<string>} Resolves when user presses a key
 */
export const waitForKeyPressed = async () => await prompt(t("pressAnyKey"));

/**
 * Display a menu and get user's choice
 * @param {string} title - Menu title to display
 * @param {Object<string, string>} menuItems - Object mapping keys to menu item labels
 * @returns {Promise<{key: string, value: string}>} Selected menu item with key and value
 */
export const choose = async (title, menuItems) => {
    const titleUi = `======== ${title} ========`;
    let ui = "";
    ui += "\n" + new Array(titleUi.length).fill("=").join("") + "\n";
    ui += titleUi + "\n";
    ui += new Array(titleUi.length).fill("=").join("");
    Object.entries(menuItems).map(([key, value]) => {
        ui += `\n${key}: ${value}`;
    });
    log(ui);

    while (true) {
        const input = await prompt("\n" + t("chooseFunction"));
        if (input in menuItems) {
            return {
                key: input,
                value: menuItems[input],
            };
        } else {
            log(t("wrongChoice"));
        }
    }
};

/**
 * Close the readline interface
 * Should be called when the application exits
 * @returns {void}
 */
export const closeReadline = () => {
    rl.close();
};

/**
 * Get the readline interface instance
 * @returns {readline.Interface} The readline interface
 */
export const getReadline = () => rl;

// Exit on readline close
rl.on("close", () => process.exit(0));

```

### scripts\menu\index.js
```js
/**
 * Menu Module - Main Entry Point
 *
 * Provides the main menu loop and re-exports menu utilities.
 * @module menu
 */

import { choose, closeReadline, waitForKeyPressed } from "./core.js";
import { t } from "../lang.js";
import { initDatabase } from "../database.js";

// Import menu handlers
import { menuDownloadAlbum, showAlbumInfo } from "./album.js";
import { menuDownloadWallMedia } from "./wall.js";
import { menuDownloadPhotoVideoOfUser } from "./user.js";
import {
    menuDownloadFromFile,
    menuSelectLanguage,
    menuFindTimelineAlbum,
    menuPrintAllUIDs,
    menuScanUIDs,
    menuProxyHealthCheck,
    menuShowHelp,
    menuFetchUserProfiles
} from "./admin.js";

// Re-export core utilities
export { prompt, choose, waitForKeyPressed, closeReadline } from "./core.js";

/**
 * Main application menu loop
 * Displays all available options and handles user navigation
 * Initializes database and manages all download/utility features
 * @returns {Promise<void>}
 */
export const menu = async () => {
    // Initialize database for UID listing
    initDatabase();

    while (true) {
        const action = await choose("FB Media Downloader Tool", {
            1: t("albumInfo"),
            2: t("findTimelinkAlbum"),
            3: t("downloadAlbum"),
            4: t("downloadWall"),
            5: t("downloadUser"),
            6: t("downloadFromUrlFile"),
            7: t("language"),
            8: t("help"),
            9: "Print all UIDs",
            10: "Scan UIDs for usernames",
            11: "Proxy Health Check",
            12: t("fetchUserProfiles"),
            13: t("exit"),
        });

        if (action.key == 1) {
            await showAlbumInfo();
        }
        if (action.key == 2) {
            await menuFindTimelineAlbum();
        }
        if (action.key == 3) {
            await menuDownloadAlbum();
        }
        if (action.key == 4) {
            await menuDownloadWallMedia();
        }
        if (action.key == 5) {
            await menuDownloadPhotoVideoOfUser();
        }
        if (action.key == 6) {
            await menuDownloadFromFile();
        }
        if (action.key == 7) {
            await menuSelectLanguage();
        }
        if (action.key == 8) {
            await menuShowHelp();
        }
        if (action.key == 9) {
            await menuPrintAllUIDs();
        }
        if (action.key == 10) {
            await menuScanUIDs();
        }
        if (action.key == 11) {
            await menuProxyHealthCheck();
        }
        if (action.key == 12) {
            await menuFetchUserProfiles();
        }
        if (action.key == 13) break;
    }

    closeReadline();
};

```

### scripts\menu\user.js
```js
/**
 * User Media Download Menu Module
 *
 * Handles the user photos/videos download submenu.
 * @module menu/user
 */

import { prompt, choose } from "./core.js";
import { t } from "../lang.js";
import { log } from "../logger.js";
import { parseUserIds } from "../utils.js";
import { downloadUserPhotos, downloadUserPhotosBatch } from "../download_user_photos.js";
import { downloadUserVideos, downloadUserVideosBatch } from "../download_user_videos.js";
import { ensureUserProfileForUIDs } from "../user_profile.js";
import { runCancellable } from "../cancellation.js";

/**
 * Menu handler for downloading user's uploaded photos and videos
 * Fetches from user's photo albums and video posts
 * Supports batch downloads for multiple user IDs
 * @returns {Promise<void>}
 */
export const menuDownloadPhotoVideoOfUser = async () => {
    while (true) {
        const action = await choose(t("downloadUserTitle"), {
            0: t("back"),
            1: t("downloadUserImagePost"),
            2: t("downloadUserVideoPost"),
        });

        if (action.key == 0) break;
        if (action.key == 1 || action.key == 2) {
            // Accept comma-separated IDs
            const target_ids_input = await prompt(t("enterUserID") + " (comma-separated)");
            if (target_ids_input != -1) {
                const target_ids = parseUserIds(target_ids_input);

                if (target_ids.length === 0) {
                    log("No valid user IDs entered.");
                    continue;
                }

                const from_cursor = await prompt(t("startPageUser"));
                const page_limit = await prompt(t("howManyPageUser"));

                if (page_limit >= 0) {
                    const options = {
                        fromCursor: from_cursor == 0 ? null : from_cursor,
                        pageLimit: page_limit == 0 ? Infinity : page_limit,
                    };

                    // Wrap download in cancellable operation
                    await runCancellable(async () => {
                        // Fetch user profiles before starting download
                        await ensureUserProfileForUIDs(target_ids);

                        // Use batch download for multiple users
                        if (target_ids.length > 1) {
                            if (action.key == 1) {
                                await downloadUserPhotosBatch(target_ids, options);
                            } else {
                                await downloadUserVideosBatch(target_ids, options);
                            }
                        } else {
                            // Single user - original function
                            if (action.key == 1) {
                                await downloadUserPhotos({ targetId: target_ids[0], ...options });
                            } else {
                                await downloadUserVideos({ targetId: target_ids[0], ...options });
                            }
                        }
                    });
                }
            }
        }
    }
};

```

### scripts\menu\wall.js
```js
/**
 * Wall Media Download Menu Module
 *
 * Handles the wall/feed media download submenu.
 * @module menu/wall
 */

import { prompt, choose } from "./core.js";
import { t } from "../lang.js";
import { log } from "../logger.js";
import { parseUserIds } from "../utils.js";
import {
    downloadWallMedia,
    downloadWallMediaLinks,
    downloadWallMediaBatch,
} from "../download_wall_media.js";
import { ensureUserProfileForUIDs } from "../user_profile.js";
import { runCancellable } from "../cancellation.js";

/**
 * Menu handler for downloading wall/feed media
 * Downloads photos and optionally videos from user's wall posts
 * Supports batch downloads for multiple user IDs
 * @returns {Promise<void>}
 */
export const menuDownloadWallMedia = async () => {
    while (true) {
        const action = await choose(t("downloadWallTitle"), {
            0: t("back"),
            1: t("downloadAllMediaInWall"),
            2: t("donwloadAllMediaLinkWall"),
        });

        if (action.key == 0) break;
        if (action.key == 1 || action.key == 2) {
            // Accept comma-separated IDs
            const target_ids_input = await prompt(t("enterTargetID") + " (comma-separated)");
            if (target_ids_input != -1) {
                const target_ids = parseUserIds(target_ids_input);

                if (target_ids.length === 0) {
                    log("No valid IDs entered.");
                    continue;
                }

                const page_limit = await prompt(t("howManyPageWall"));
                if (page_limit >= 0) {
                    const include_video = await prompt(t("downloadVideoWall"));
                    const largest_photo = await prompt(t("downloadHDWall"));
                    const is_largest_photo = largest_photo == "0" ? false : true;

                    if (action.key == 2 && is_largest_photo) {
                        log(t("saveHDLinkNotSupported"));
                    }

                    const options = {
                        includeVideo: include_video == 1 ? true : false,
                        pageLimit: page_limit == 0 ? Infinity : page_limit,
                        isGetLargestPhoto: is_largest_photo,
                    };

                    // Wrap download in cancellable operation
                    await runCancellable(async () => {
                        // Fetch user profiles before starting download
                        await ensureUserProfileForUIDs(target_ids);

                        if (action.key == 1) {
                            // Download media (not links)
                            if (target_ids.length > 1) {
                                // Batch mode
                                await downloadWallMediaBatch(target_ids, options);
                            } else {
                                // Single user
                                await downloadWallMedia({
                                    targetId: target_ids[0],
                                    ...options
                                });
                            }
                        } else {
                            // Download links - batch not needed for links
                            await downloadWallMediaLinks({
                                targetId: target_ids[0], // Only use first ID for links
                                ...options
                            });
                        }
                    });
                }
            }
        }
    }
};

```

### scripts\profile\fetch.js
```js
/**
 * Profile Fetch Module
 *
 * Handles fetching user profile data from the Facebook Graph API.
 * Fetches fields individually for better resilience - if one fails, others still work.
 * @module profile/fetch
 */

import { FB_API_HOST } from '../constants.js';
import { ACCESS_TOKEN } from '../../config.js';
import { myFetch, sleep } from '../utils.js';
import { log } from '../logger.js';

/**
 * Profile fields to fetch individually for resilience
 * Each group is fetched separately so if one fails, others still work
 * @constant {Array<string[]>}
 */
const PROFILE_FIELD_GROUPS = [
    ['id', 'name', 'first_name', 'last_name', 'link'],  // Basic - should always work
    ['gender'],
    ['about'],
    ['email'],
    ['birthday'],
    ['age_range'],
    ['hometown'],
    ['location'],
    ['relationship_status', 'significant_other'],
    ['religion', 'political'],
    ['work'],
    ['education'],
    ['website'],
    ['friends.summary(true)'],
];

/**
 * Fetch a single field group from Facebook API
 * Silently skips errors for individual fields
 * @param {string} uid - User ID
 * @param {string[]} fields - Field names to fetch
 * @returns {Promise<Object>} Field data (may be partial or empty)
 */
export const fetchFieldGroup = async (uid, fields) => {
    const fieldsStr = fields.join(',');
    const url = `${FB_API_HOST}/${uid}?fields=${fieldsStr}&access_token=${ACCESS_TOKEN}`;

    try {
        const data = await myFetch(url);
        if (!data || data.error) {
            // Silently skip errors for individual fields
            return {};
        }
        return data;
    } catch (error) {
        return {};
    }
};

/**
 * Fetch user profile by trying each field group individually
 * Uses resilient fetching - if one group fails, others still work
 * @param {string} uid - User ID
 * @returns {Promise<Object|null>} Complete profile or null on total failure
 */
export const fetchUserProfile = async (uid) => {
    log(`\nüîç Fetching profile for UID: ${uid}`);

    let profile = {};
    let hasAnyData = false;

    for (const fields of PROFILE_FIELD_GROUPS) {
        const data = await fetchFieldGroup(uid, fields);
        if (Object.keys(data).length > 0) {
            profile = { ...profile, ...data };
            hasAnyData = true;
        }
        // Small delay between requests
        await sleep(200);
    }

    if (!hasAnyData || !profile.id) {
        log(`‚ùå Could not fetch any data for UID: ${uid}`);
        return null;
    }

    return profile;
};

/**
 * Fetch ALL page likes by following pagination
 * @param {string} uid - User ID
 * @param {number} limit - Maximum number of likes to fetch (default: unlimited)
 * @returns {Promise<Array>} Array of all liked pages
 */
export const fetchAllLikes = async (uid, limit = Infinity) => {
    const allLikes = [];
    let url = `${FB_API_HOST}/${uid}/likes?fields=id,name,created_time&limit=100&access_token=${ACCESS_TOKEN}`;
    let page = 1;

    log('üìã Fetching liked pages...');

    while (url && allLikes.length < limit) {
        try {
            const data = await myFetch(url);

            if (!data || data.error) {
                log(`   ‚ö†Ô∏è Likes error: ${data?.error?.message || 'Unknown error'}`);
                break;
            }

            if (data.data && data.data.length > 0) {
                allLikes.push(...data.data);
                process.stdout.write(`\r   Pages: ${page} (${allLikes.length} likes)`);
            }

            url = data.paging?.next || null;
            page++;

            if (url) {
                await sleep(300);
            }

        } catch (error) {
            log(`   ‚ö†Ô∏è Error: ${error.message}`);
            break;
        }
    }

    log(`\n   ‚úÖ Total: ${allLikes.length} likes`);
    return allLikes;
};

```

### scripts\profile\index.js
```js
/**
 * Profile Module - Main Entry Point
 *
 * Provides high-level profile fetching and saving operations.
 * @module profile
 */

import { DATABASE_ENABLED, PLATFORM_FACEBOOK } from '../../config.js';
import { getDatabase } from '../database/connection.js';
import { getOrCreateUser } from '../database/users.js';
import { log } from '../logger.js';

// Import fetch functions
import { fetchUserProfile, fetchAllLikes, fetchFieldGroup } from './fetch.js';

// Import save functions
import {
    saveProfile,
    saveWorkHistory,
    saveEducationHistory,
    saveLikes,
    updateUsername,
    hasUserProfile
} from './save.js';

// Re-export all functions
export {
    fetchUserProfile,
    fetchAllLikes,
    fetchFieldGroup,
    saveProfile,
    saveWorkHistory,
    saveEducationHistory,
    saveLikes,
    updateUsername,
    hasUserProfile
};

/**
 * Display profile summary to console
 * @param {Object} profile - Profile data
 */
function displayProfileSummary(profile) {
    log(`   üìõ ${profile.name || 'Unknown'} (${profile.gender || 'N/A'})`);
    if (profile.location?.name) log(`   üìç ${profile.location.name}`);
    if (profile.work?.length) log(`   üíº ${profile.work[0].employer?.name || 'Unknown'}`);
    if (profile.education?.length) log(`   üéì ${profile.education[0].school?.name || 'Unknown'}`);
}

/**
 * Fetch user profile and save to database
 * Main entry point for getting complete user profile
 * Matches original test_user_profile.js logic
 * @param {string} uid - User's UID
 * @param {Object} options - Options
 * @param {boolean} options.includeLikes - Whether to fetch likes (default: false)
 * @param {number} options.likesLimit - Maximum likes to fetch (default: unlimited)
 * @returns {Promise<Object>} Result with profile data and save status
 */
export const fetchAndSaveProfile = async (uid, options = {}) => {
    const { includeLikes = false, likesLimit = Infinity } = options;

    const db = getDatabase();
    if (!db || !DATABASE_ENABLED) {
        // Just fetch without saving
        const profile = await fetchUserProfile(uid);
        return { profile, saved: false, reason: 'database_disabled', isNew: false, changedFields: [] };
    }

    try {
        // Fetch profile
        const profile = await fetchUserProfile(uid);

        if (!profile || !profile.id) {
            return { profile: null, saved: false, reason: 'fetch_failed', isNew: false, changedFields: [] };
        }

        // Display summary
        displayProfileSummary(profile);

        // Get or create user
        const userId = getOrCreateUser(PLATFORM_FACEBOOK, uid);
        if (!userId) {
            return { profile, saved: false, reason: 'user_creation_failed', isNew: false, changedFields: [] };
        }

        // Save profile (now returns {saved, isNew, changedFields})
        const saveResult = saveProfile(db, userId, profile);
        if (!saveResult.saved) {
            return { profile, saved: false, reason: 'profile_save_failed', isNew: false, changedFields: [] };
        }

        log(`   ‚úÖ Profile saved (user_id: ${userId})`);

        // Save work history (normalized)
        if (profile.work && profile.work.length > 0) {
            const workSaved = saveWorkHistory(db, userId, profile.work);
            log(`   ‚úÖ Work history: ${workSaved} records`);
        }

        // Save education history (normalized)
        if (profile.education && profile.education.length > 0) {
            const eduSaved = saveEducationHistory(db, userId, profile.education);
            log(`   ‚úÖ Education: ${eduSaved} records`);
        }

        // Update username
        if (profile.name) {
            updateUsername(db, userId, profile.name, profile.link);
        }

        // Fetch and save likes if requested
        if (includeLikes) {
            const likes = await fetchAllLikes(uid, likesLimit);
            if (likes.length > 0) {
                const likesResult = saveLikes(db, userId, likes);
                log(`   ‚úÖ Likes: ${likesResult.saved} saved, ${likesResult.skipped} skipped`);
            }
        }

        return {
            profile,
            saved: true,
            userId,
            isNew: saveResult.isNew,
            changedFields: saveResult.changedFields
        };

    } catch (error) {
        log(`‚ö†Ô∏è Error in fetchAndSaveProfile: ${error.message}`);
        return { profile: null, saved: false, reason: error.message, isNew: false, changedFields: [] };
    }
};

/**
 * Ensure a user has a profile, fetching if missing
 * @param {string} uid - User's UID
 * @param {number} platformId - Platform ID (default: 1 for Facebook)
 * @returns {Promise<{exists: boolean, fetched: boolean}>} Status
 */
export const ensureUserProfile = async (uid, platformId = PLATFORM_FACEBOOK) => {
    if (hasUserProfile(uid, platformId)) {
        return { exists: true, fetched: false };
    }

    const result = await fetchAndSaveProfile(uid);
    return { exists: result.saved, fetched: result.saved };
};

/**
 * Ensure profiles exist for multiple UIDs, fetching missing ones
 * @param {string[]} uids - Array of UIDs
 * @returns {Promise<{total: number, fetched: number, existing: number, failed: number}>} Stats
 */
export const ensureUserProfileForUIDs = async (uids) => {
    const stats = { total: uids.length, fetched: 0, existing: 0, failed: 0 };

    for (const uid of uids) {
        if (hasUserProfile(uid)) {
            stats.existing++;
            continue;
        }

        const result = await fetchAndSaveProfile(uid);
        if (result.saved) {
            stats.fetched++;
        } else {
            stats.failed++;
        }
    }

    if (stats.fetched > 0) {
        log(`üìä Profile sync: ${stats.fetched} fetched, ${stats.existing} already existed, ${stats.failed} failed`);
    }

    return stats;
};

```

### scripts\profile\save.js
```js
/**
 * Profile Save Module
 *
 * Handles saving user profile data to the database.
 * Uses normalized database structure (fb_entities, fb_pages, user_page_likes).
 * @module profile/save
 */

import { DATABASE_ENABLED, PLATFORM_FACEBOOK } from '../../config.js';
import { getDatabase } from '../database/connection.js';
import { log } from '../logger.js';

/**
 * Get or create an entity in the fb_entities table
 * Used for normalizing locations, employers, schools, etc.
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {string} fbId - Facebook ID of the entity
 * @param {string} name - Display name of the entity
 * @param {string} entityType - Type of entity (location, employer, school, etc.)
 * @returns {number|null} Entity ID or null if fbId is missing
 */
function getOrCreateEntity(db, fbId, name, entityType) {
    if (!fbId) return null;

    let entity = db.prepare('SELECT id FROM fb_entities WHERE fb_id = ?').get(fbId);
    if (!entity) {
        const result = db.prepare(
            'INSERT INTO fb_entities (fb_id, name, entity_type) VALUES (?, ?, ?)'
        ).run(fbId, name, entityType);
        return result.lastInsertRowid;
    } else {
        // Update name if changed
        db.prepare('UPDATE fb_entities SET name = ?, updated_at = CURRENT_TIMESTAMP WHERE fb_id = ?').run(name, fbId);
        return entity.id;
    }
}

/**
 * Get or create a Facebook page in the fb_pages table
 * Used for storing liked pages
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {string} pageId - Facebook page ID
 * @param {string} pageName - Display name of the page
 * @returns {number} Page record ID
 */
function getOrCreatePage(db, pageId, pageName) {
    let page = db.prepare('SELECT id FROM fb_pages WHERE page_id = ?').get(pageId);

    if (!page) {
        const result = db.prepare('INSERT INTO fb_pages (page_id, page_name) VALUES (?, ?)').run(pageId, pageName);
        return result.lastInsertRowid;
    } else {
        db.prepare('UPDATE fb_pages SET page_name = ?, updated_at = CURRENT_TIMESTAMP WHERE page_id = ?').run(pageName, pageId);
        return page.id;
    }
}

/**
 * Fields to track for change detection
 * @constant {string[]}
 */
const TRACKED_FIELDS = [
    'name', 'first_name', 'last_name', 'about', 'email', 'link',
    'birthday', 'age_range_min', 'age_range_max', 'gender',
    'hometown', 'location', 'relationship_status', 'significant_other',
    'religion', 'political', 'work_history', 'education_history',
    'website', 'friend_count'
];

/**
 * Detect which fields have changed between old and new profile data
 * @param {Object} oldProfile - Existing profile from database
 * @param {Object} newData - New profile data to compare
 * @returns {string[]} Array of field names that changed
 */
function detectProfileChanges(oldProfile, newData) {
    if (!oldProfile) return []; // New profile, no history needed

    const changedFields = [];

    for (const field of TRACKED_FIELDS) {
        const oldVal = oldProfile[field];
        const newVal = newData[field];

        // Normalize for comparison (both null/undefined treated as equal)
        const oldNorm = oldVal === undefined ? null : (typeof oldVal === 'object' ? JSON.stringify(oldVal) : oldVal);
        const newNorm = newVal === undefined ? null : (typeof newVal === 'object' ? JSON.stringify(newVal) : newVal);

        if (oldNorm !== newNorm) {
            changedFields.push(field);
        }
    }

    return changedFields;
}

/**
 * Save a snapshot of the old profile to history before update
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {Object} oldProfile - The profile data before update
 * @param {string[]} changedFields - List of fields that will change
 * @returns {boolean} True if saved successfully
 */
function saveProfileHistory(db, oldProfile, changedFields) {
    if (!oldProfile || changedFields.length === 0) return false;

    try {
        db.prepare(`
            INSERT INTO user_profiles_history (
                user_id, name, first_name, last_name, about, email, link,
                birthday, age_range_min, age_range_max, gender,
                hometown, location, relationship_status, significant_other,
                religion, political, work_history, education_history,
                website, friend_count, hometown_id, current_location_id, significant_other_uid,
                changed_fields
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            oldProfile.user_id,
            oldProfile.name, oldProfile.first_name, oldProfile.last_name,
            oldProfile.about, oldProfile.email, oldProfile.link,
            oldProfile.birthday, oldProfile.age_range_min, oldProfile.age_range_max, oldProfile.gender,
            oldProfile.hometown, oldProfile.location, oldProfile.relationship_status, oldProfile.significant_other,
            oldProfile.religion, oldProfile.political, oldProfile.work_history, oldProfile.education_history,
            oldProfile.website, oldProfile.friend_count,
            oldProfile.hometown_id, oldProfile.current_location_id, oldProfile.significant_other_uid,
            JSON.stringify(changedFields)
        );
        return true;
    } catch (error) {
        log(`‚ö†Ô∏è Error saving profile history: ${error.message}`);
        return false;
    }
}

/**
 * Get existing profile from database for change detection
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @returns {Object|null} Existing profile or null
 */
export function getExistingProfile(db, userId) {
    try {
        return db.prepare('SELECT * FROM user_profiles WHERE user_id = ?').get(userId);
    } catch (error) {
        return null;
    }
}

/**
 * Save user profile to database with change tracking
 * Detects changes and saves history before updating
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @param {Object} profile - Profile data from Facebook API
 * @returns {{saved: boolean, isNew: boolean, changedFields: string[]}} Save result with change info
 */
export function saveProfile(db, userId, profile) {
    // Get or create hometown and location entities
    const hometownId = profile.hometown ? getOrCreateEntity(db, profile.hometown.id, profile.hometown.name, 'location') : null;
    const locationId = profile.location ? getOrCreateEntity(db, profile.location.id, profile.location.name, 'location') : null;
    const significantOtherUid = profile.significant_other?.id || null;

    // Prepare the new data object for comparison
    const newProfileData = {
        name: profile.name || null,
        first_name: profile.first_name || null,
        last_name: profile.last_name || null,
        about: profile.about || null,
        email: profile.email || null,
        link: profile.link || null,
        birthday: profile.birthday || null,
        age_range_min: profile.age_range?.min || null,
        age_range_max: profile.age_range?.max || null,
        gender: profile.gender || null,
        hometown: profile.hometown ? JSON.stringify(profile.hometown) : null,
        location: profile.location ? JSON.stringify(profile.location) : null,
        relationship_status: profile.relationship_status || null,
        significant_other: profile.significant_other ? JSON.stringify(profile.significant_other) : null,
        religion: profile.religion || null,
        political: profile.political || null,
        work_history: profile.work ? JSON.stringify(profile.work) : null,
        education_history: profile.education ? JSON.stringify(profile.education) : null,
        website: profile.website || null,
        friend_count: profile.friends?.summary?.total_count || null,
    };

    // Check for existing profile and detect changes
    const existingProfile = getExistingProfile(db, userId);
    const isNew = !existingProfile;
    let changedFields = [];

    if (existingProfile) {
        changedFields = detectProfileChanges(existingProfile, newProfileData);

        // Save history if there are changes
        if (changedFields.length > 0) {
            saveProfileHistory(db, existingProfile, changedFields);
        }
    }

    const sql = `
        INSERT INTO user_profiles (
            user_id, name, first_name, last_name, about, email, link,
            birthday, age_range_min, age_range_max, gender,
            hometown, location, relationship_status, significant_other,
            religion, political, work_history, education_history, website, friend_count,
            hometown_id, current_location_id, significant_other_uid
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(user_id) DO UPDATE SET
            name = excluded.name,
            first_name = excluded.first_name,
            last_name = excluded.last_name,
            about = excluded.about,
            email = excluded.email,
            link = excluded.link,
            birthday = excluded.birthday,
            age_range_min = excluded.age_range_min,
            age_range_max = excluded.age_range_max,
            gender = excluded.gender,
            hometown = excluded.hometown,
            location = excluded.location,
            relationship_status = excluded.relationship_status,
            significant_other = excluded.significant_other,
            religion = excluded.religion,
            political = excluded.political,
            work_history = excluded.work_history,
            education_history = excluded.education_history,
            website = excluded.website,
            friend_count = excluded.friend_count,
            hometown_id = excluded.hometown_id,
            current_location_id = excluded.current_location_id,
            significant_other_uid = excluded.significant_other_uid,
            updated_at = CURRENT_TIMESTAMP
    `;

    try {
        db.prepare(sql).run(
            userId,
            newProfileData.name,
            newProfileData.first_name,
            newProfileData.last_name,
            newProfileData.about,
            newProfileData.email,
            newProfileData.link,
            newProfileData.birthday,
            newProfileData.age_range_min,
            newProfileData.age_range_max,
            newProfileData.gender,
            newProfileData.hometown,
            newProfileData.location,
            newProfileData.relationship_status,
            newProfileData.significant_other,
            newProfileData.religion,
            newProfileData.political,
            newProfileData.work_history,
            newProfileData.education_history,
            newProfileData.website,
            newProfileData.friend_count,
            hometownId,
            locationId,
            significantOtherUid
        );
        return { saved: true, isNew, changedFields };
    } catch (error) {
        log(`‚ö†Ô∏è Error saving profile: ${error.message}`);
        return { saved: false, isNew, changedFields: [] };
    }
}

/**
 * Save user's work history using normalized structure
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @param {Array} workArray - Array of work history objects from Facebook API
 * @returns {number} Number of work records saved
 */
export function saveWorkHistory(db, userId, workArray) {
    if (!workArray || workArray.length === 0) return 0;

    const insertWork = db.prepare(`
        INSERT INTO user_work_history 
        (user_id, employer_id, position_id, location_id, start_date, end_date, fb_work_id)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(user_id, fb_work_id) DO UPDATE SET
            employer_id = excluded.employer_id,
            position_id = excluded.position_id,
            location_id = excluded.location_id,
            start_date = excluded.start_date,
            end_date = excluded.end_date
    `);

    let saved = 0;
    for (const work of workArray) {
        const employerId = work.employer ? getOrCreateEntity(db, work.employer.id, work.employer.name, 'employer') : null;
        const positionId = work.position ? getOrCreateEntity(db, work.position.id, work.position.name, 'position') : null;
        const locationId = work.location ? getOrCreateEntity(db, work.location.id, work.location.name, 'location') : null;

        try {
            insertWork.run(
                userId,
                employerId,
                positionId,
                locationId,
                work.start_date || null,
                work.end_date || null,
                work.id || null
            );
            saved++;
        } catch (e) {
            // Skip duplicates silently
        }
    }
    return saved;
}

/**
 * Save user's education history using normalized structure
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @param {Array} educationArray - Array of education history objects from Facebook API
 * @returns {number} Number of education records saved
 */
export function saveEducationHistory(db, userId, educationArray) {
    if (!educationArray || educationArray.length === 0) return 0;

    const insertEdu = db.prepare(`
        INSERT INTO user_education_history 
        (user_id, school_id, concentration_id, education_type, year, fb_education_id)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(user_id, fb_education_id) DO UPDATE SET
            school_id = excluded.school_id,
            concentration_id = excluded.concentration_id,
            education_type = excluded.education_type,
            year = excluded.year
    `);

    let saved = 0;
    for (const edu of educationArray) {
        const schoolId = edu.school ? getOrCreateEntity(db, edu.school.id, edu.school.name, 'school') : null;
        let concentrationId = null;
        if (edu.concentration && edu.concentration.length > 0) {
            concentrationId = getOrCreateEntity(db, edu.concentration[0].id, edu.concentration[0].name, 'concentration');
        }

        try {
            insertEdu.run(
                userId,
                schoolId,
                concentrationId,
                edu.type || null,
                edu.year?.name || null,
                edu.id || null
            );
            saved++;
        } catch (e) {
            // Skip duplicates silently
        }
    }
    return saved;
}

/**
 * Save user's page likes using normalized structure
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @param {Array} likes - Array of liked page objects with id, name, created_time
 * @returns {{saved: number, skipped: number}} Count of saved and skipped likes
 */
export function saveLikes(db, userId, likes) {
    if (!likes || likes.length === 0) {
        return { saved: 0, skipped: 0 };
    }

    const insertLike = db.prepare(`
        INSERT INTO user_page_likes (user_id, fb_page_id, liked_at)
        VALUES (?, ?, ?)
        ON CONFLICT(user_id, fb_page_id) DO UPDATE SET
            liked_at = excluded.liked_at
    `);

    let saved = 0;
    let skipped = 0;

    for (const like of likes) {
        try {
            const fbPageId = getOrCreatePage(db, like.id, like.name);
            insertLike.run(userId, fbPageId, like.created_time || null);
            saved++;
        } catch (error) {
            skipped++;
        }
    }

    return { saved, skipped };
}

/**
 * Update username history for a user
 * @param {import('better-sqlite3').Database} db - Database instance
 * @param {number} userId - Internal database user ID
 * @param {string} name - Current username/display name
 * @param {string} link - Profile URL
 * @returns {boolean} True if username was updated, false if unchanged
 */
export function updateUsername(db, userId, name, link) {
    const existing = db.prepare('SELECT * FROM username_history WHERE user_id = ? AND is_current = 1').get(userId);

    if (!existing || existing.username !== name) {
        db.prepare('UPDATE username_history SET is_current = 0 WHERE user_id = ?').run(userId);
        db.prepare('INSERT INTO username_history (user_id, username, profile_url) VALUES (?, ?, ?)').run(userId, name, link);
        return true;
    }
    return false;
}

/**
 * Check if a user profile exists in the database
 * @param {string} uid - User's UID
 * @param {number} platformId - Platform ID (default: 1 for Facebook)
 * @returns {boolean} True if profile exists
 */
export function hasUserProfile(uid, platformId = PLATFORM_FACEBOOK) {
    const db = getDatabase();
    if (!db || !DATABASE_ENABLED) return false;

    try {
        const result = db.prepare(`
            SELECT 1 FROM user_profiles up
            JOIN users u ON up.user_id = u.id
            WHERE u.platform_id = ? AND u.uid = ?
            LIMIT 1
        `).get(platformId, uid);
        return !!result;
    } catch (error) {
        return false;
    }
}

```

### scripts\__tests__\database.users.test.js
```js
/**
 * Tests for database/users.js
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import Database from 'better-sqlite3';
import fs from 'fs';

// Create a test database
const TEST_DB_PATH = './test_users.db';

describe('database/users.js', () => {
    let db;

    beforeEach(() => {
        // Create fresh test database
        db = new Database(TEST_DB_PATH);
        db.pragma('foreign_keys = ON');

        // Create required tables
        db.exec(`
            CREATE TABLE IF NOT EXISTS platforms (
                platform_id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform_name TEXT NOT NULL UNIQUE
            );
            INSERT OR IGNORE INTO platforms (platform_name) VALUES ('facebook'), ('instagram');
            
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform_id INTEGER NOT NULL,
                uid TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (platform_id) REFERENCES platforms(platform_id),
                UNIQUE(platform_id, uid)
            );
            
            CREATE TABLE IF NOT EXISTS username_history (
                user_his_id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                username TEXT NOT NULL,
                profile_url TEXT,
                changed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                is_current BOOLEAN DEFAULT 1,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            );
        `);
    });

    afterEach(() => {
        if (db) db.close();
        if (fs.existsSync(TEST_DB_PATH)) fs.unlinkSync(TEST_DB_PATH);
    });

    describe('User CRUD operations', () => {
        it('should create a new user', () => {
            const result = db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            expect(result.lastInsertRowid).toBeGreaterThan(0);
        });

        it('should get user by UID', () => {
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            const user = db.prepare('SELECT * FROM users WHERE platform_id = ? AND uid = ?').get(1, '123456');
            expect(user).toBeDefined();
            expect(user.uid).toBe('123456');
        });

        it('should return undefined for non-existent user', () => {
            const user = db.prepare('SELECT * FROM users WHERE platform_id = ? AND uid = ?').get(1, 'nonexistent');
            expect(user).toBeUndefined();
        });

        it('should enforce unique constraint on platform_id + uid', () => {
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            expect(() => {
                db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            }).toThrow();
        });
    });

    describe('Username history', () => {
        it('should add username to history', () => {
            const userResult = db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            const userId = userResult.lastInsertRowid;

            db.prepare('INSERT INTO username_history (user_id, username) VALUES (?, ?)').run(userId, 'TestUser');

            const history = db.prepare('SELECT * FROM username_history WHERE user_id = ?').get(userId);
            expect(history.username).toBe('TestUser');
            expect(history.is_current).toBe(1);
        });

        it('should track username changes', () => {
            const userResult = db.prepare('INSERT INTO users (platform_id, uid) VALUES (?, ?)').run(1, '123456');
            const userId = userResult.lastInsertRowid;

            // Add first username
            db.prepare('INSERT INTO username_history (user_id, username, is_current) VALUES (?, ?, 1)').run(userId, 'OldName');

            // Mark old as not current, add new
            db.prepare('UPDATE username_history SET is_current = 0 WHERE user_id = ?').run(userId);
            db.prepare('INSERT INTO username_history (user_id, username, is_current) VALUES (?, ?, 1)').run(userId, 'NewName');

            const allHistory = db.prepare('SELECT * FROM username_history WHERE user_id = ? ORDER BY user_his_id').all(userId);
            expect(allHistory).toHaveLength(2);
            expect(allHistory[0].username).toBe('OldName');
            expect(allHistory[0].is_current).toBe(0);
            expect(allHistory[1].username).toBe('NewName');
            expect(allHistory[1].is_current).toBe(1);
        });
    });
});

```

### scripts\__tests__\profile.save.test.js
```js
/**
 * Tests for profile/save.js - Change Detection
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import Database from 'better-sqlite3';
import fs from 'fs';

const TEST_DB_PATH = './test_profile_save.db';

describe('profile/save.js - Change Detection', () => {
    let db;

    beforeEach(() => {
        db = new Database(TEST_DB_PATH);
        db.pragma('foreign_keys = ON');

        // Create required tables
        db.exec(`
            CREATE TABLE IF NOT EXISTS platforms (
                platform_id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform_name TEXT NOT NULL UNIQUE
            );
            INSERT OR IGNORE INTO platforms (platform_name) VALUES ('facebook');
            
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                platform_id INTEGER NOT NULL,
                uid TEXT NOT NULL,
                UNIQUE(platform_id, uid)
            );
            
            CREATE TABLE IF NOT EXISTS user_profiles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL UNIQUE,
                name TEXT,
                first_name TEXT,
                last_name TEXT,
                about TEXT,
                email TEXT,
                link TEXT,
                birthday TEXT,
                age_range_min INTEGER,
                age_range_max INTEGER,
                gender TEXT,
                hometown TEXT,
                location TEXT,
                relationship_status TEXT,
                significant_other TEXT,
                religion TEXT,
                political TEXT,
                work_history TEXT,
                education_history TEXT,
                website TEXT,
                friend_count INTEGER,
                hometown_id INTEGER,
                current_location_id INTEGER,
                significant_other_uid TEXT,
                fetched_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
            
            CREATE TABLE IF NOT EXISTS user_profiles_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                snapshot_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                name TEXT,
                first_name TEXT,
                last_name TEXT,
                changed_fields TEXT
            );
        `);
    });

    afterEach(() => {
        if (db) db.close();
        if (fs.existsSync(TEST_DB_PATH)) fs.unlinkSync(TEST_DB_PATH);
    });

    describe('Profile CRUD', () => {
        it('should insert new profile', () => {
            // Create user first
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (1, ?)').run('123456');

            // Insert profile
            const result = db.prepare(`
                INSERT INTO user_profiles (user_id, name, gender) VALUES (1, ?, ?)
            `).run('Test User', 'male');

            expect(result.lastInsertRowid).toBeGreaterThan(0);

            const profile = db.prepare('SELECT * FROM user_profiles WHERE user_id = 1').get();
            expect(profile.name).toBe('Test User');
            expect(profile.gender).toBe('male');
        });

        it('should update existing profile with ON CONFLICT', () => {
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (1, ?)').run('123456');

            // Insert initial profile
            db.prepare(`
                INSERT INTO user_profiles (user_id, name, gender) VALUES (1, ?, ?)
            `).run('Old Name', 'male');

            // Update using ON CONFLICT
            db.prepare(`
                INSERT INTO user_profiles (user_id, name, gender) VALUES (1, ?, ?)
                ON CONFLICT(user_id) DO UPDATE SET name = excluded.name, gender = excluded.gender
            `).run('New Name', 'female');

            const profile = db.prepare('SELECT * FROM user_profiles WHERE user_id = 1').get();
            expect(profile.name).toBe('New Name');
            expect(profile.gender).toBe('female');
        });
    });

    describe('Change Detection Logic', () => {
        const TRACKED_FIELDS = ['name', 'gender', 'location'];

        function detectChanges(oldProfile, newData) {
            if (!oldProfile) return [];
            const changedFields = [];
            for (const field of TRACKED_FIELDS) {
                if (oldProfile[field] !== newData[field]) {
                    changedFields.push(field);
                }
            }
            return changedFields;
        }

        it('should return empty array for identical data', () => {
            const old = { name: 'Test', gender: 'male', location: 'NYC' };
            const newData = { name: 'Test', gender: 'male', location: 'NYC' };
            expect(detectChanges(old, newData)).toEqual([]);
        });

        it('should detect single field change', () => {
            const old = { name: 'Test', gender: 'male', location: 'NYC' };
            const newData = { name: 'New Name', gender: 'male', location: 'NYC' };
            expect(detectChanges(old, newData)).toEqual(['name']);
        });

        it('should detect multiple field changes', () => {
            const old = { name: 'Test', gender: 'male', location: 'NYC' };
            const newData = { name: 'New Name', gender: 'female', location: 'LA' };
            expect(detectChanges(old, newData)).toEqual(['name', 'gender', 'location']);
        });

        it('should return empty array for new profile (null old)', () => {
            const newData = { name: 'Test', gender: 'male', location: 'NYC' };
            expect(detectChanges(null, newData)).toEqual([]);
        });
    });

    describe('Profile History', () => {
        it('should save snapshot to history table', () => {
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (1, ?)').run('123456');

            // Save to history
            db.prepare(`
                INSERT INTO user_profiles_history (user_id, name, first_name, changed_fields)
                VALUES (?, ?, ?, ?)
            `).run(1, 'Old Name', 'Old First', JSON.stringify(['name', 'first_name']));

            const history = db.prepare('SELECT * FROM user_profiles_history WHERE user_id = 1').get();
            expect(history).toBeDefined();
            expect(history.name).toBe('Old Name');
            expect(JSON.parse(history.changed_fields)).toEqual(['name', 'first_name']);
        });

        it('should allow multiple history entries per user', () => {
            db.prepare('INSERT INTO users (platform_id, uid) VALUES (1, ?)').run('123456');

            db.prepare('INSERT INTO user_profiles_history (user_id, name, changed_fields) VALUES (?, ?, ?)').run(1, 'Name V1', '["name"]');
            db.prepare('INSERT INTO user_profiles_history (user_id, name, changed_fields) VALUES (?, ?, ?)').run(1, 'Name V2', '["name"]');

            const history = db.prepare('SELECT * FROM user_profiles_history WHERE user_id = 1').all();
            expect(history).toHaveLength(2);
        });
    });
});

```

### scripts\__tests__\utils.test.js
```js
/**
 * Tests for utils.js
 */
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import {
    checkFileExist,
    createIfNotExistDir,
    deleteFile,
    parseUserIds,
    sleep
} from '../utils.js';

describe('utils.js', () => {
    const testDir = './test_temp_dir';
    const testFile = './test_temp_file.txt';

    afterEach(() => {
        // Cleanup
        if (fs.existsSync(testFile)) fs.unlinkSync(testFile);
        if (fs.existsSync(testDir)) fs.rmSync(testDir, { recursive: true });
    });

    describe('checkFileExist', () => {
        it('should return false for non-existent file', () => {
            expect(checkFileExist('./nonexistent_file.xyz')).toBe(false);
        });

        it('should return true for existing file', () => {
            fs.writeFileSync(testFile, 'test');
            expect(checkFileExist(testFile)).toBe(true);
        });
    });

    describe('createIfNotExistDir', () => {
        it('should create directory if it does not exist', () => {
            expect(fs.existsSync(testDir)).toBe(false);
            createIfNotExistDir(testDir);
            expect(fs.existsSync(testDir)).toBe(true);
        });

        it('should not throw if directory already exists', () => {
            fs.mkdirSync(testDir, { recursive: true });
            expect(() => createIfNotExistDir(testDir)).not.toThrow();
        });
    });

    describe('deleteFile', () => {
        it('should delete existing file', () => {
            fs.writeFileSync(testFile, 'test');
            expect(fs.existsSync(testFile)).toBe(true);
            deleteFile(testFile);
            expect(fs.existsSync(testFile)).toBe(false);
        });

        it('should not throw for non-existent file', () => {
            expect(() => deleteFile('./nonexistent.txt')).not.toThrow();
        });
    });

    describe('parseUserIds', () => {
        it('should parse comma-separated UIDs', () => {
            const result = parseUserIds('123,456,789');
            expect(result).toEqual(['123', '456', '789']);
        });

        it('should trim whitespace', () => {
            const result = parseUserIds('  123 , 456 ,  789  ');
            expect(result).toEqual(['123', '456', '789']);
        });

        it('should filter empty values', () => {
            const result = parseUserIds('123,,456,');
            expect(result).toEqual(['123', '456']);
        });

        it('should return empty array for empty input', () => {
            expect(parseUserIds('')).toEqual([]);
            expect(parseUserIds('   ')).toEqual([]);
        });
    });

    describe('sleep', () => {
        it('should delay for specified milliseconds', async () => {
            const start = Date.now();
            await sleep(100);
            const elapsed = Date.now() - start;
            expect(elapsed).toBeGreaterThanOrEqual(90); // Allow some tolerance
            expect(elapsed).toBeLessThan(200);
        });
    });
});

```
